<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!--
/*
 * Copyright (c) 2003-2005 Alexandre Ratchov
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met:
 *
 * 	- Redistributions of source code must retain the above
 * 	  copyright notice, this list of conditions and the
 * 	  following disclaimer.
 *
 * 	- Redistributions in binary form must reproduce the above
 * 	  copyright notice, this list of conditions and the
 * 	  following disclaimer in the documentation and/or other
 * 	  materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-->

<HTML>
<HEAD>
<TITLE>midish 0.2 - tutorial</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</HEAD>
<BODY bgcolor="white" text="black" link="blue" vlink="navy">

<H1>Table of contents</H1>
<P>
<UL>
<LI><A href="#intro">Introduction</A>
<LI><A href="#dev">Device setup</A>
<LI><A href="#filt">Filtering/routing</A>
<LI><A href="#chan">Channels</A>
<LI><A href="#time">Time structure</A>
<LI><A href="#track">Tracks</A>
<LI><A href="#info">Obtaining information</A>
<LI><A href="#save">Saving and loading songs</A>
<LI><A href="#export">Import/export standard MIDI files</A>
<LI><A href="#language">The interpreter's language</A>
<LI><A href="#example">Example session</A>
</UL>


<A name="intro"></A>
<H1>Introduction</H1>

	<P>
	Midish is a MIDI sequencer/filter driven by a command-line 
	interpreter (like a shell).
	
	Once midish started, the interpreter prompts
	for commands. 

	You can configure midi-devices, 
	create tracks, define channel/controller mappings,
	route events from one device to another, playback, 
	record etc.

	To start midish, just type:
	<PRE>
	midish
	</PRE>

	At the prompt you can issue commands, like:
	<PRE>
	print "hello world"
	</PRE>

	Midish has two modes: <I>prompt mode</I> and <I>performance mode</I>.

	<P>
	In prompt mode, midish interactively waits for commands
	from the command-line.

	Midi devices aren't used, they are let closed in order
	to let other applications to use them.

	<P>
	In performance mode, midish processes midi input/output
	in real-time.

	Commands cannot be issued on the command-line.
	This mode is typically used for playback and record.

<A name="dev"></A>
<H1>Device setup</H1>

	In midish, midi-devices are numbered from 0 to 15.
	Each midi-device has its "slot number". For instance, 
	suppose	that we have a midi sound module known as
	<TT>/dev/rmidi3</TT> and a midi keyboard known as
	<TT>/dev/rmidi2</TT>.

	To configure the module as device number 0 and
	the keyboard as device number 1, just type:
	<PRE>
	devattach 0 "/dev/rmidi3"
	devattach 1 "/dev/rmidi2"
	</PRE>
	
	<P>
	<B>Note:</B>
	To make easier the import/export procedure from systems 
	with different configurations, I strongly recommend to 
	attach the main sound module (the one you use mostly)
	as device number 0.
	
	<P>
	In order to check that the sound module is properly configured
	play the demo song: put your module (output midi device) 
	in "general midi" mode and type:
	<PRE>
	songload "sample.sng"
	songplay
	</PRE>

	When your configuration is setup, put your "devattach" 
	commands in your <TT>$HOME/.midishrc</TT>. It will be
	automatically executed the next time you run midish.
	
<A name="filt"></A>
<H1>Filtering/routing</H1>

	<P>
	Midish supports midi filtering: you can define <I>a filter</I> to 
	transform input events and send them to the output. 
	
	Filters are in general used to:
	<UL>
	<LI>
	route events from a device to another
	<LI>
	map a controller to another
	<LI>
	split the keyboard
	<LI>
	etc...
	</UL>

	<P>
	If no filters are defined, in performance mode input is send 
	to the output as-is. Filters are defined as follows:
	<PRE>
	filtnew myfilt			# define filter 'myfilt'
	</PRE>
	initially the filter is empty and will send input to output
	as-is.

	Several filters can be defined, however only the
	<I>current filter</I> will run in performance
	mode. The current filter is set as follows:
	<PRE>
	songsetcurfilt myfilt		# make 'myfilt' the current filter
	</PRE>
	
	Once the filter is created, filtering rules can be added
	using <TT>filtdevmap, filtchanmap, filtctlmap, filtkeymap</TT>.
	Rules can be listed with <TT>filtinfo</TT>. Currently it
	is not yet possible to modify/remove individual rules, the
	only way is to remove all rules with <TT>filtreset</TT>.
	
<H2>Device redirections</H2>

	Let us define a filter and use it to route events from
	device number 1 (the midi keyboard) to device number 0
	(the sound module). First we define the filter and
	make it the current filter:
	<PRE>
	filtnew mydevmap		# define filter 'mydevmap'
	songsetcurfilt mydevmap		# make 'mydevmap' the current filter
	</PRE>
	then we define a "device map" rule:
	<PRE>
	filtdevmap mydevmap 1 0		# route device 1 -> device 0
	</PRE>
	Finally, we can test the filter, by starting performance mode:
	<PRE>
	songidle
	</PRE>
	The filter will run until "Enter" is hit on the console.
	
<H2>Channel maps</H2>

	Let us define a filter that routes events from
	device 1, channel 0 (first channel of the keyboard) to
	device 0, channel 9 (default drum channel of the sound module).
	First, we define the filter:
	<PRE>
	filtnew mydrums			# define filter 'mydrums'
	songsetcurfilt mydrums		# make 'mydevmap' the current filter
	</PRE>
	then we define a rule that maps device 1 channel 0 to 
	device 0 channel 9:
	<PRE>
	filtchanmap mydrums {1 0} {0 9}
	</PRE>
	The device/channel pair is in braces. The first <TT>{1 0}</TT>
	is the input device/channel and <TT>{0 9}</TT> is the output channel.
	Finally we try the filter:
	<PRE>
	songidle
	</PRE>
	Playing on channel 0 of the keyboard will make
	sound channel 9 of the sound-module.

<H2>Controller maps</H2>

	Let us continue with the later filter. Now 
	we will add a new rule that maps the modulation wheel (controller 1)
	of device 1, channel 0 (first channel of the keyboard) to
	the expression controller (number 11) of device 0, channel 9 (the
	default drums channel of the sound module).
	<PRE>
	filtctlmap mydrums {1 0} {0 9} 1 11
	</PRE>
	the first three arguments are the name of the filter, 
	the input and the output device/channel pair. The 4-th
	argument is the controller number on the input (1 = modulation)
	and the 5-th argument is the controller number on the output (11 = expression).
	Rules of the filter can be listed on the console as follows:
	<PRE>
	filtinfo mydrums
	</PRE>
	normally this prints something like:
	<PRE>
	ctlmap {1 0} {0 9} 1 11 id
	chanmap {1 0} {0 9}
	</PRE>

<H2>Transpose</H2>

	Let us create a filter that transposes by 12 half-tones
	(one octave) notes played on device 1, channel 0 (keyboard) and
	sends them on device 0 channel 2 (sound-module). First
	we create the input filter:
	<PRE>
	filtnew mypiano			# define filter 'mypiano'
	songsetcurfilt mypiano		# make 'mypiano' the current filter
	</PRE>
	then, we add a channel-map and a key-map rule to the filter:
	<PRE>
	filtchanmap mypiano {1 0} {0 2}
	filtkeymap mypiano {1 0} {0 2} 0 127 12
	</PRE>
	both rules are necessary. Note events are handled by 
	the key-rule and other events (controllers) fall trough
	the channel-rule. Arguments 4 and 5 to <TT>filtkeymap</TT>
	give the note range that will be transposed 
	(from 0 to 127, i.e. the whole keyboard)
	and the 6-th argument give the number of half-tones 
	(12, one octave).
	
<H2>Keyboard splits</H2>

	In the same way we can create a keyboard-split with two
	key-rules and two channel-rules. 
	Let us split the
	keyboard in two parts (left and right) on note 64 (note E3),  in
	the middle. 
	Notes on the left part 	will be routed to
	channel 3  of the sound module and notes on the right
	part will be routed to channel 2 of the sound module.
	<PRE>
	filtnew mysplit
	filtchanmap mysplit {1 0} {0 2}
	filtkeymap mysplit {1 0} {0 2} 0 63 0
	filtchanmap mysplit {1 0} {0 3}
	filtkeymap mysplit {1 0} {0 3} 64 127 0
	songsetcurfilt mysplit
	</PRE>
	<P>
	Defining filters seem quite tedious, however it's possible
	to define procedures that do the same in a very simpler way.

<A name="chan"></A>
<H1>Channels</H1>

	Because midish handles multiple devices, instead of
	using midi-channels, it uses device/midi-channel pairs.
	We'll often refer by <I>channel</I>
	the device/midi-channel pair. As we have seen, channels
	are handled by two-item lists, like this:
	<PRE>
	{0 1}			# device 0, midi-channel 1
	</PRE>
	Channels can also be named, as follows:
	<PRE>
	channew mybass {0 1}
	</PRE>
	this defines a named-channel <TT>mybass</TT> that can
	be used instead of the <TT>{0 1}</TT> pair.
	
<H2>Channel configuration</H2>

	Since a channel represents a musical instrument, 
	midish allow us to attach to the channel definition 
	basic configuration. For instance;
	to select patch 34 on channel drums, we attach
	a "program change" event:
	<PRE>
	chanconfev mybass { pc mybass 32 }
	</PRE>
	the list-argument gives the event to attach to the channel.
	Such events are sent to the output when performance starts,
	for instance just before playback starts. This approach avoids
	flooding midi devices when playback starts.
	
	In the same way, to set the volume (controller 7) 
	of this channel to 120:
	<PRE>
	chanconfev mybass { ctl mybass 7 120 }
	</PRE>
	If several events of the same type are attached, 
	the just the last one is kept. So, to change
	the volume to 125, we just need:
	<PRE>
	chanconfev mybass { ctl mybass 7 125 }
	</PRE>
	
<A name="time"></A>
<H1>Time structure</H1>

	<P>
	In midish, time is split in <I>measures</I>. Each measure
	is split in <I>beats</I> and each beat is split in 
	<I>tics</I>. The <I>tic</I> is the fundamental
	time unit in midish. Duration of tics is fixed
	by the <I>tempo</I>. By default midish uses:
		<UL>
		<LI>24 tics per beat
		<LI>4 beats per measure
		<LI>120 beats per minute
		</UL>
	From the musical point of view, a beat often corresponds to
	a quarter note, to an eight note etc... 
	By default 
	an unit note corresponds to 96 tics, thus by default
	one beat corresponds to one quarter note, i.e. 
	the time signature is 4/4.
	
	
<H2>Metronome</H2>

	In order to "hear" time, we can use a metronome. It is
	used only in play and record modes. It produces
	a click sound on every beat. Let us start the metronome:
	<PRE>
	metroswitch 1		# switch the metronome on
	songplay		# start playback
	</PRE>
	The metronome has two kind of click-sound:
	<UL>
	<LI> high-click: on the first beat of the measure
	<LI> low-click: on the other beats.
	</UL>
	The click-sound can be configured by giving a couple 
	of note-on events, as follows:
	<PRE>
	metroconf {non {0 9} 48 127} {non {0 9} 64 100}
	</PRE>
	this configures the high-click with note 48, velocity 127 on
	device 0, channel 9 and the low-click with note 64, velocity 100
	on device 0, channel 9.

<H2>Time signature changes</H2>

	Time signature changes are achieved by inserting or
	deleting measures. For instance let us start
	a song with time signature of 4/4 (at measure 0) and
	change the time signature to 6/8 at measure 2 during
	5 measures:
	<PRE>
	songtimeins 0 2 4 4	# 4/4 at measure 0 during 2 measures
	songtimeins 2 5 6 8	# 8/6 at measure 2 during 5 measures
	metroswitch 1		# switch the metronome on
	songplay		# test it
	</PRE>
	Now we can suppress measure number 2 (the first 6/8 measure)
	<PRE>
	songtimerm  2 1		# remove 1 measure starting a measure 2
	metroswitch 1		# switch the metronome on
	songplay		# test it
	</PRE>
	
<H2>Tempo changes</H2>
	
	Tempo changes are achieved simply by giving the measure
	number and the tempo value in beats per minute. For
	instance, the following changes tempo on measure 0
	to 100 beats per minute and on measure 2 to 180 beats 
	per minute.
	<PRE>
	songsettempo 0 100
	songsettempo 2 180
	</PRE>


<H2>Moving in the song</H2>

	We can select the current position in the song to
	measure number 3 as follows:
	<PRE>
	songsetcurpos 3
	</PRE>
	This will make <TT>songrecord</TT> and <TT>songplay</TT>
	start at this particular position instead of measure
	number 0.
	
<A name="track"></A>
<H1>Tracks</H1>
	
	<P>
	A track is a piece of music, namely an ordered in time list 
	of midi events. In play mode, midish play simultaneously
	all defined tracks, in record-mode it plays all defined tracks
	and records the current track.
	
	<P>
	Tracks aren't binded to any particular device/channel; a track
	can contain midi data from any device/channel. A track can have its 
	<I>current filter</I>; in this case, midi events
	are passed through that filter before being recorded. If the
	track has no current filter, then the song current
	filter is used instead. If there is neither track current
	filter nor song current filter, then midi events
	from all devices are recorded as-is.

<H2>Recording track without a filter</H2>

	<P>
	Let us define a track and record data
	as-is from all midi devices.
	<PRE>
	tracknew mytrack
	songsetcurtrack mytrack
	songrecord
	</PRE>
	tracks are played as follows:
	<PRE>
	songplay
	</PRE>
	However, with the above configuration this will not
	work as expected because events from the input
	keyboard (device number 1) will be recorded as-is and then 
	sent back to the device number 1 instead of being sent
	to the sound module (device number 0).
	
<H2>Recording track with a filter</H2>

	Let us create a filter and use it to
	record to the above track:
	<PRE>
	filtnew mypiano
	filtchanmap mypiano {1 0} {0 0}		# dev1/chan0 -> dev0/chan0
	tracksetcurfilt mypiano
	trackrecord
	</PRE>
	
<H2>Basic editing of a track</H2>

	<P>
	Most track editing functions in midish take at least the
	following arguments:
	<UL>
	<LI> start measure
	<LI> number of measures
	<LI> precision/quantum (in tics).
	</UL>
	For instance let us blank measure number 3 of
	track <TT>mypiano</TT>:
	<PRE>
	trackblank mypiano 3 1 (96 / 16) {}
	</PRE>
	the 3-rd argument set the precision to sixteenth note
	(assuming 96 tics per unit note). This
	means that notes starting just before the 3-rd measure will
	be suppressed. 
	This is useful, because often recorded notes
	doesn't start exactly on the measure boundary. The precision
	argument let you edit a track that is not quantised.
	The latest argument (empty list) selects the events to be 
	deleted (see section "event ranges" in the manual).

	<P>
	In a similar way, one can cut a piece of a track, 
	for instance let us cut 2 measures starting
	at measure number 5:
	<PRE>
	trackcut mypiano 5 2 (96 / 16)
	</PRE>
	
	<P>
	Now, let us insert 2 blank measure at
	measure number 3:
	<PRE>
	trackinsert mypiano 3 2 (96 / 16)
	</PRE>
	
	<P>
	A track portion ca be copied into
	another track as follows:
	<PRE>
	trackcopy mypiano 3 2 mypiano2 5 (96 / 16) {}
	</PRE>
	this will copy 2 measures starting from measure
	number 3 into (the already existing) track <TT>mypiano2</TT>
	at measure 5.
	The latest argument (empty list) selects the events to be 
	copied (see section "event ranges" in the manual).
	

<H2>Track quantisation</H2>

	In order to make a track sound more "precise", 
	on can regularise it by rounding note-positions
	to the nearest round position. The following
	will quantise 4 measures starting at measure number
	3 by rounding notes to the nearest quarter notes.
	<PRE>
	trackquant mypiano 3 4 (96 / 4) 75
	</PRE>
	The last arguments gives the percent of quantisation.
	100% means full quantisation and 0% leans no
	quantisation at all. This is useful because full quantisation
	often sound to regular especially on acoustic patches.
	

<H2>Checking a track</H2>

	It is possible that a midi device transmits 
	bogus midi data. In principle when a filter is
	used data is rewritten and contains no anomalies.
	The following scans the track and removes bogus notes
	and unused controller events:
	<PRE>
	trackcheck mytrack
	</PRE>
	This function can be useful to remove 
	nested notes when a track is recorded twice (or more) 
	without being erased.


<A name="sysex"></A>
<H1>Using system exclusive messages</H1>

	Midish can send several system exclusive messages
	to midi devices before starting performance mode.
	Tipically, this feature can be used to change 
	the configuration of the midi devices. System
	exclusive ('sysex') messages are stored into 
	named banks. To create a sysex bank named <TT>mybank</TT>:
	<PRE>
	sysexnew mybank
	</PRE>
	Then we can add comme messages:
	<PRE>
	sysexadd mybank 0 {0xF0 0x7E 0x7F 0x09 0x01 0xF7}
	</PRE>	
	This will store the "General-Midi ON" messages into the
	bank. The sencond argument (here "0") is the device number
	to which the message will be sent when performance mode
	is entered. To send the latter messages to 
	the corresponding device, just enter performance mode,
	for instance:
	<PRE>
	songidle
	</PRE>
	Sysex messages can be recorded from
	midi devices, this is useful to save "bulk dumps"
	from synthtisers. Sysex messages are automatically
	recorded on the <I>current bank</I>. So, to record
	a sysex:
	<PRE>
	songsetcursysex mybank
	songrecord
	</PRE>
	The next time performance mode is entered, recorded
	sysex messages will be sent back to the device.
	Information about the recorded sysex messages 
	can be obtained as follows:
	<PRE>
	sysexinfo mybank
	</PRE>
	A bank can be cleared by:
	<PRE>
	sysexclear mybank {}
	</PRE>
	the second argument is a (empty) pattern, that matches
	any sysex message in the bank. The following will remove
	only sysex messages starting with 0xF0 0x7E 0x7F:
	<PRE>
	sysexclear mybank {0xF0 0x7E 0x7F}
	</PRE>
	Sysex messages recorded from any device can be configured
	to be sent to other devices. To change the device number
	of all messages to 1:
	<PRE>
	sysexsetunit mybank 1 {}
	</PRE>
	the second argument is a (empty) pattern, that matches
	any sysex message in the bank. The following will change 
	the device number of only sysex messages starting 
	with 0xF0 0x7E 0x7F:
	<PRE>
	sysexsetunit mybank 1 {0xF0 0x7E 0x7F}
	</PRE>
	
<A name="info"></A>
<H1>Obtaining information</H1>

	<P>
	The following functions gives some informations
	about midish objects:
	<PRE>
	songinfo
	chaninfo mydrums	# about channel 'mydrums'
	filtinfo myfilt		# about filter 'myfilt'
	</PRE>
	
	<P>
	Objects can be listed as follows:
	<PRE>
	print [tracklist]
	print [chanlist]
	print [filtlist]
	print [devlist]
	</PRE>

	<P>
	Current values can be obtained as follows:
	<PRE>
	print [songgetunit]		# tics per unit note
	print [songgetcurpos]		# print current position
	print [songgetcurfilt]		# current filter
	print [songgetcurtrack]		# current track
	print [songgetcursysex]
	print [trackgetcurfilt mypiano]	# current filter of track 'mypiano'
	</PRE>

	<P>
	The device and the midi channel of a channel definition
	can be obtained as follows:
	<PRE>
	print [changetch mydrums]	# print midi chan number
	print [changetdev mydrums]	# print device number
	</PRE>
	
	<P>
	To check if object exists:
	<PRE>
	print [chanexists]
	print [filtexists]
	print [trackexists]
	print [sysexexists]
	</PRE>
	this will print 1 if the corresponding object exists
	and 0 otherwise.
	

<A name="save"></A>
<H1>Saving and loading songs</H1>

	<P>
	A song can be saved into a file. All channel definitions, 
	filters, tracks, their properties, 
	and values of the current track, current 
	filter will be saved by:
	<PRE>
	songsave "myfile"
	</PRE>
	In a similar way, the song can be load from a file 
	as follows:
	<PRE>
	songload "myfile"
	</PRE>
	
	<P>
	Note that the "local settings" (like device configuration,
	metronome settings) are not saved. 
	
<A name="export"></A>
<H1>Import/export standard MIDI files</H1>

	<P>
	Standard MIDI files type 0 or 1 can be imported. Each
	track in the standard midi file corresponds to a track in midish.
	Tracks are named <TT>trk00</TT>, <TT>trk01</TT>, ... 
	All midi events are binded to device number 0. Only the following
	meta events are handled:
		<UL>
		<LI> tempo changes
		<LI> time signature changes
		</UL>
	all meta-events are removed from the "voice" tracks and
	are moved into the midish's meta-track. Finally tracks
	are checked for anomalies. Example:
	<PRE>
	songimportsmf "mysong.mid"
	</PRE>
	
	<P>
	Midish songs can be exported into standard midi files.
	Tempo changes and time signature changes are exported
	to a meta-track (first track of the midi file). Each
	channel definition is exported as a track containing
	the channel configuration events. Voice tracks
	are exported as is in separate tracks. Note that device 
	numbers of midi events are not stored in the midi file
	because the file format does not allow this.	
	Example:
	<PRE>
	songexportsmf "mysong.mid"
	</PRE>
	
<A name="language"></A>
<H1>The interpreter's language</H1>

	<P>
	In order to achieve any simple task with midish, we often have
	to write several long statements. In order to make midish easier
	to use we can use variables and/or define our own procedures.
	For more details about the interpreted language, please
	refer to the <A href="manual.html">manual</A>.

<H2>Global variables</H2>

	<P>
	Variables can be used to store numbers, strings and
	references to tracks, channels and filters, like:
	
	<PRE>
	let x = 53		# store 53 into 'x'
	print $x		# prints '53'
	</PRE>
	
	The <TT>let</TT> keyword is used to assign values to 
	variables and the dollar sign ("<TT>$</TT>") is used
	to obtain variable values.

<H2>Defining simple procedures</H2>

	<P>
	For instance, let
	us create a procedure named "<TT>i</TT>" that just replaces
	<TT>songidle</TT> in order to avoid typing its name.
	<PRE>
	proc i { songidle; }
	</PRE>
	The <TT>proc</TT> keyword is followed by the procedure
	name and then follows a list of statements between
	braces. In a similar way can define the following
	procedures:
	<PRE>
	proc p {
		metroswith 0		# turn off metronome
		songplay		# start playback
	}
	
	proc r {
		metroswitch 1		# turn on metronome
		songrecord		# start recording
	}
	</PRE>
	
	<P>
	Procedures can take arguments. 
	For instance, let us define a procedure named <TT>nf</TT> 
	that creates a new filter and then makes it the current filter:
	<PRE>
	proc nf filtname {
		filtnew $filtname
		songsetcurfilt $filtname
	}
	</PRE>
	After the name of the procedure follows the argument names list
	that can be arbitrary identifiers. The value of the arguments
	is obtained by preceding the variable name by the dollar
	sign ("$"). We can use the above procedure to create a filter:
	<PRE>
	nf myfilt
	</PRE>
	
	A lot of similar procedures are defined in the
	sample <TT>midishrc</TT> file, shipped in the source
	tar-ball. The make midish easy to use, most of
	the usual tasks can be performed with only 2 or
	three character statements.
	
	<P>
	Procedure and variables definitions can be
	stored in the <TT>~/.midishrc</TT> file. It will be
	automatically executed the next time you run midish.
		
	
<H2>Sample rc-file</H2>
	
	<P>
	The sample rc file shipped in the source tar-balls
	contains a lot of examples of procedure definitions.
	They can be used the drive midish:
	
	<P>
	<B><TT>nf filtname</TT></B>
		<BLOCKQUOTE>
		create a new filter named <TT>filtname</TT>
		and make it the current filter
		</BLOCKQUOTE>

	<B><TT>cf filtname</TT></B>
		<BLOCKQUOTE>
		set the current filter to <TT>filtname</TT>
		</BLOCKQUOTE>
		
	<B><TT>devdrop devnum</TT></B>
		<BLOCKQUOTE>
		make the current filter drop events from 
		device number <TT>devnum</TT>
		</BLOCKQUOTE>
	
	<B><TT>devmap idevnum odevnum</TT></B>
		<BLOCKQUOTE>
		make the current filter route events
		from device number <TT>idevnum</TT>
		to device <TT>odevnum</TT>
		</BLOCKQUOTE>

	<B><TT>chandrop chan</TT></B>
		<BLOCKQUOTE>
		make the current filter drop events from
		{channel device} pair <TT>chan</TT>
		</BLOCKQUOTE>
	
	<B><TT>chanmap ichan ochan</TT></B>
		<BLOCKQUOTE>
		make the current filter route events
		from {channel device} pair <TT>ichan</TT>
		to {channel device} pair <TT>ochan</TT>
		</BLOCKQUOTE>

	<B><TT>chandrop chan</TT></B>
		<BLOCKQUOTE>
		make the current filter drop events from
		{device channel} pair <TT>chan</TT>
		</BLOCKQUOTE>
	
	<B><TT>chanmap ichan ochan</TT></B>
		<BLOCKQUOTE>
		make the current filter route events
		from {channel device} pair <TT>ichan</TT>
		to {device channel} pair <TT>ochan</TT>
		</BLOCKQUOTE>
	
	<B><TT>ctldrop ichan ictl</TT></B>
		<BLOCKQUOTE>
		make the current filter drop controller number
		<TT>ictl</TT> on {device channel} pair <TT>ichan</TT>.
		</BLOCKQUOTE>

	<B><TT>ctlmap ichan ochan ictl octl</TT></B>
		<BLOCKQUOTE>
		make the current filter route controller number
		<TT>ictl</TT> on {device channel} pair <TT>ichan</TT>
		to conroller <TT>octl</TT> on <TT>ochan</TT>
		</BLOCKQUOTE>
		
	<B><TT>nt trackname</TT></B>
		<BLOCKQUOTE>
		create a track named <TT>trackname</TT>
		and set its default filter (for recording) to
		the current filter and make it the current track
		</BLOCKQUOTE>
		
	<B><TT>ct trackname</TT></B>
		<BLOCKQUOTE>
		make <TT>trackname</TT> the current track; it
		if has a default filter, then make it the current
		filter for the song
		</BLOCKQUOTE>
		
	<B><TT>tf filtname</TT></B>
		<BLOCKQUOTE>
		set the current track's filter the <TT>filtname</TT>
		</BLOCKQUOTE>
	
	<B><TT>nc channame</TT></B>
		<BLOCKQUOTE>
		create a new channel named <TT>channame</TT>
		</BLOCKQUOTE>
		
	<B><TT>i</TT></B>
		<BLOCKQUOTE>
		go into performance mode and run the current filter
		of the current track.
		</BLOCKQUOTE>
		
	<B><TT>p</TT></B>
		<BLOCKQUOTE>
		go in performance mode and play the all defined 
		tracks and run the current filter of the current track
		</BLOCKQUOTE>
		
	<B><TT>r</TT></B>
		<BLOCKQUOTE>
		go in preformance mode and record the current track
		using its current filter
		</BLOCKQUOTE>
		
	<B><TT>l</TT></B>
		<BLOCKQUOTE>
		list tracks, channels and filter
		and pront some additionnal info
		</BLOCKQUOTE>
		
	<B><TT>g measurenum</TT></B> 
		<BLOCKQUOTE>
		move the current song position to 
		measure number <TT>measurenum</TT>. Play/record
		and all editting procedures that follow
		will start at that position
		</BLOCKQUOTE>

	<B><TT>n denominator</TT></B>
		<BLOCKQUOTE>
		set the current note length for quantisation
		to <TT>denominator</TT>, 4 means quarter-note, 
		8 means eigth-note, 16 means sixeenth-note etc...
		</BLOCKQUOTE>
		
	<B><TT>q num rate</TT></B>
		<BLOCKQUOTE>
		quantise <TT>num</TT> measures
		of the current track starting at the current position.
		</BLOCKQUOTE>
		
	<B><TT>cut num</TT></B>
		<BLOCKQUOTE>
		cuts (removes events and blank space) <TT>num</TT>
		measures from the current track at the current position
		</BLOCKQUOTE>
		
	<B><TT>clr num</TT></B>
		<BLOCKQUOTE>
		clears (removes events but not blank space) <TT>num</TT>
		measures from the current track at the current position
		</BLOCKQUOTE>
		
	<B><TT>ins num</TT></B> 
		<BLOCKQUOTE>
		insert <TT>num</TT> empty measures into the
		current track at the current position
		</BLOCKQUOTE>
		
	<B><TT>copy num pos</TT></B> 
		<BLOCKQUOTE>
		copy <TT>num</TT> measures from the current
		position at measure number <TT>pos</TT>
		on the current track
		</BLOCKQUOTE>

	<B><TT>gcut num</TT></B> 
		<BLOCKQUOTE>
		same as <TT>cut</TT> but acts on all tracks
		simultaneously ("g" like global).
		</BLOCKQUOTE>
		
	<B><TT>gins num</TT></B> 
		<BLOCKQUOTE>
		same as <TT>ins</TT> but acts on all tracks
		simultaneously ("g" like global).
		</BLOCKQUOTE>

	<B><TT>gcopy num</TT></B> 
		<BLOCKQUOTE>
		same as <TT>copy</TT> but acts on all tracks
		simultaneously ("g" like global).
		</BLOCKQUOTE>

	<B><TT>mute trackname</TT></B>
		<BLOCKQUOTE>
		mute track <TT>trackname</TT>. The track will
		be no more audible during playback.
		</BLOCKQUOTE>
		
	<B><TT>solo</TT></B>
		<BLOCKQUOTE>
		mute all tracks but current
		</BLOCKQUOTE>

	<B><TT>unmute trackname</TT></B>
		<BLOCKQUOTE>
		unmute track <TT>trackname</TT>. The track will
		be audible during playback.
		</BLOCKQUOTE>
		
	<B><TT>nomute</TT></B>
		<BLOCKQUOTE>
		unmute all tracks.
		</BLOCKQUOTE>	
		
	<B><TT>save filename</TT></B>
		<BLOCKQUOTE>
		save the whole project (filters, tracks, channels,
		and current settings) in file <TT>filename</TT>.
		</BLOCKQUOTE>
				
	<B><TT>load filename</TT></B>
		<BLOCKQUOTE>
		load the whole project (filters, tracks, channels,
		and current settings) from file <TT>filename</TT>.
		</BLOCKQUOTE>
		
	<B><TT>tempo bpm</TT></B>
		<BLOCKQUOTE>
		change the tempo at the current position
		to <TT>bpm</TT> beats per measure.
		</BLOCKQUOTE>
		
	<B><TT>timeins num numerator denominator</TT></B> 
		<BLOCKQUOTE>
		insert <TT>num</TT> measures in the
		meta-track with the time signature 
		<TT>numerator/denominator</TT>
		</BLOCKQUOTE>
		
	<B><TT>timerm num</TT></B>
		<BLOCKQUOTE>
		remove <TT>num</TT> measures from
		the meta-track.
		</BLOCKQUOTE>
		
	<B><TT>gmon devnum</TT></B>
		<BLOCKQUOTE>
		send "general midi on" system excusive message
		to device number <TT>devnum</TT>
		</BLOCKQUOTE>
		
	<B><TT>gmoff devnum</TT></B>
		<BLOCKQUOTE>
		send "general midi off" system excusive message
		to device number <TT>devnum</TT>
		</BLOCKQUOTE>
		
	<B><TT>gmp chan patch</TT></B> 
		<BLOCKQUOTE>
		configures named-channel <TT>chan</TT>
		to use general midi patch number <TT>patch</TT>.
		(this will send program change event when
		performance mode is entered).
		</BLOCKQUOTE>
		
	<B><TT>vol chan value</TT></B> 
		<BLOCKQUOTE>
		set volume (controller number 7) of
		channel <TT>chan</TT> to <TT>value</TT>.
		</BLOCKQUOTE>
		
	<B><TT>reverb chan value</TT></B> 
		<BLOCKQUOTE>
		set reverb (controller number 91) of
		channel <TT>chan</TT> to <TT>value</TT>.
		</BLOCKQUOTE>
		
	<B><TT>chorus chan value</TT></B> 
		<BLOCKQUOTE>
		set chorus (controller number 93) of
		channel <TT>chan</TT> to <TT>value</TT>.
		</BLOCKQUOTE>
			
<A name="example"></A>
<H1>Example sessions</H1>
<H2>Example - midi filtering</H2>
	
	The following session show how to 
	configure a keyboard split:
		
	<PRE>
	> nc bass {0 1}
	> nc piano {0 2}
	> gmp bass 33
	> gmp piano 2
	> nf split
	> filtchanmap split {1 0} bass 
	> filtchanmap split {1 0} piano
	> filtkeymap split {1 0} bass 0 63 (-12)
	> filtkeymap split {1 0} piano 64 127 0   
	> filtinfo split
	keymap {1 0} {0 2} 65 127 0 id
	keymap {1 0} {0 1} 0 64 116 id
	chanmap {1 0} {0 2}
	chanmap {1 0} {0 1}
	> l
	tracks:
	channels:
	    bass ( dev: 0 chan: 1 )
	    piano ( dev: 0 chan: 2 )
	filters:
	 -> split :
	tics_per_unit=96, curpos=0, curquant=0
	> i
	song_idle: started loop...

	press enter to finish

	> reverb bass 120
	> vol piano 120
	> i
	song_idle: started loop...

	press enter to finish

	> save "piano-bass"
	</PRE>

	First we define 2 named-channels 
	<TT>bass</TT> on device 0, channel 1
	and <TT>piano</TT> on device 0 channel 2.
	Then we assign patches to respective
	channels. After this, we define a new
	filter <TT>split</TT> and we add
	rules corresponding to keyboard-split
	on note number 64 (note E3), the bass is 
	transposed by -12 haftones (one octave).
	Finally we set the bass reverb to 120
	and the piano volume to 120.


<H2>Example - recording a track</H2>

	The following session show how to
	record a track:
	<PRE>
	> nc drums {0 9}
	> nf drums
	> chanmap {1 0} drums
	> nt dr1
	> r
	song_record: started loop, waiting for a start event...

	press enter to finish
	song_record: got a start

	> n 16
	> q 8 75
	> p
	song_play: starting loop, waiting for a start event...

	press enter to finish
	song_play: got a start

	> l 
	tracks:
	 -> dr1 ( record: drums )
	channels:
	    drums ( dev: 0 chan: 9 )
	filters:
	 -> drums :
	tics_per_unit=96, curpos=0, curquant=6
	> save "myrythm"
	</PRE>
	first, we define the <TT>drum</TT> channel
	on device 0, channel 9. Then we create a 
	filter with the same name, that
	routes events from device 1, channel 0 
	(the keyboard input channel) to 
	the drum channel. Then we define 
	a new track named <TT>dr1</TT> an we start recording.
	Finally, we set the quantisation step to 16 
	(sixteenth note), we quantise 8 measures of 
	the track we start playback.

<HR>
<SMALL><EM>
Copyright (c) 2003-2005 Alexandre Ratchov<BR>
Last updated may 11, 2005 	
</EM></SMALL>
	

</BODY>
</HTML>
