<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>midish - tutorial</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</HEAD>
<BODY bgcolor="white" text="black" link="blue" vlink="navy">

<H1>Table of contents</H1>
<P>
<UL>
<LI><A href="#intro">Introduction</A>
<LI><A href="#dev">Device setup</A>
<LI><A href="#filt">Filtering/routing</A>
<LI><A href="#chan">Channels</A>
<LI><A href="#time">Time structure</A>
<LI><A href="#track">Tracks</A>
<LI><A href="#info">Obtaining information</A>
<LI><A href="#save">Saving and loading songs</A>
<LI><A href="#export">Import/export standard MIDI files</A>
<LI><A href="#language">The interpreter's language</A>
<LI><A href="#example">Example session</A>
</UL>


<A name="intro"></A>
<H1>Introduction</H1>

	<P>
	Midish is a MIDI sequencer/filter driven by a command-line 
	interpreter (like a shell).
	
	Once midish started, the interpreter prompts
	for commands. 

	You can configure midi-devices, 
	create tracks, define channel/controller mappings,
	route events from one device to another, playback, 
	record etc.

	To start midish, just type:
	<PRE>
	midish
	</PRE>

	At the prompt you can issue commands, like:
	<PRE>
	print "hello world"
	</PRE>

	Midish has two modes: <I>prompt mode</I> and <I>performance mode</I>.

	<P>
	In prompt mode, midish interactively waits for commands
	from the command-line.

	Midi devices aren't used, they are let closed in order
	to let other applications to use them.

	<P>
	In performance mode, midish processes midi input/output
	in real-time.

	Commands cannot be issued on the command-line.
	This mode is typically used for playback and record.

<A name="dev"></A>
<H1>Device setup</H1>

	In midish, midi-devices are numbered from 0 to 15.
	Each midi-device has its "slot number". For instance, 
	suppose	that we have a midi sound module known as
	<TT>/dev/rmidi3</TT> and a midi keyboard known as
	<TT>/dev/rmidi2</TT>.

	To configure the module as device number 0 and
	the keyboard as device number 1, just type:
	<PRE>
	devattach 0 "/dev/rmidi3"
	devattach 1 "/dev/rmidi2"
	</PRE>
	
	<P>
	<B>Note:</B>
	To make easier the import/export procedure from systems 
	with different configurations, I strongly recommend to 
	attach the main sound module (the one you use mostly)
	as device number 0.
	
	<P>
	In order to check that the sound module is properly configured
	play the demo song: put your module (output midi device) 
	in "general midi" mode and type:
	<PRE>
	songload "sample.sng"
	songplay
	</PRE>

	When your configuration is setup, put your "devattach" 
	commands in your <TT>$HOME/.midishrc</TT>. It will be
	automatically executed the next time you run midish.
	
<A name="filt"></A>
<H1>Filtering/routing</H1>

	<P>
	Midish supports midi filtering: you can define <I>a filter</I> to 
	transform input events and send them to the output. 
	
	Filters are in general used to:
	<UL>
	<LI>
	route events from a device to another
	<LI>
	map a controller to another
	<LI>
	split the keyboard
	<LI>
	etc...
	</UL>

	<P>
	If no filters are defined, in performance mode input is send 
	to the output as-is. Filters are defined as follows:
	<PRE>
	filtnew myfilt			# define filter 'myfilt'
	</PRE>
	initially the filter is empty and will send input to output
	as-is.
	Several filters can be defined, however only the
	<I>current filter</I> will run in performance
	mode. The current filter is set as follows:
	<PRE>
	songsetcurfilt myfilt		# make 'myfilt' the current filter
	</PRE>
	
	Once the filter is created, filtering rules can be added
	using <TT>filtdevmap, filtchanmap, filtctlmap, filtkeymap</TT>.
	Rules can be listed with <TT>filtinfo</TT>. Currently it
	is not yet possible to modify/remove individual rules, the
	only way is to remove all rules with <TT>filtreset</TT>.
	
<H2>Device redirections</H2>

	Let us define a filter and use it to route events from
	device number 1 (the midi keyboard) to device number 0
	(the sound module). First we define the filter and
	make it the current filter:
	<PRE>
	filtnew mydevmap		# define filter 'mydevmap'
	songsetcurfilt mydevmap		# make 'mydevmap' the current filter
	</PRE>
	then we define a "device map" rule:
	<PRE>
	filtdevmap mydevmap 1 0		# route device 1 -> device 0
	</PRE>
	Finally, we can test the filter, by starting performance mode:
	<PRE>
	songidle
	</PRE>
	The filter will run until "Enter" is hit on the console.
	
<H2>Channel maps</H2>

	Let us define a filter that routes events from
	device 1, channel 0 (first channel of the keyboard) to
	device 0, channel 9 (default drum channel of the sound module).
	First, we define the filter:
	<PRE>
	filtnew mydrums			# define filter 'mydrums'
	songsetcurfilt mydrums		# make 'mydevmap' the current filter
	</PRE>
	then we define a rule that maps device 1 channel 0 to 
	device 0 channel 9:
	<PRE>
	filtchanmap mydrums {1 0} {0 9}
	</PRE>
	The device/channel pair is in braces. The first <TT>{1 0}</TT>
	is the input device/channel and <TT>{0 9}</TT> is the output channel.
	Finally we try the filter:
	<PRE>
	songidle
	</PRE>
	Playing on channel 0 of the keyboard will make
	sound channel 9 of the sound-module.

<H2>Controller maps</H2>

	Let us continue with the later filter. Now 
	we will add a new rule that maps the modulation wheel (controller 1)
	of device 1, channel 0 (first channel of the keyboard) to
	the expression controller (number 11) of device 0, channel 9 (the
	default drums channel of the sound module).
	<PRE>
	filtctlmap mydrums {1 0} {0 9} 1 11
	</PRE>
	the first three arguments are the name of the filter, 
	the input and the output device/channel pair. The 4-th
	argument is the controller number on the input (1 = modulation)
	and the 5-th argument is the controller number on the output (11 = expression).
	Rules of the filter can be listed on the console as follows:
	<PRE>
	filtinfo mydrums
	</PRE>
	normally this prints something like:
	<PRE>
	ctlmap {1 0} {0 9} 1 11 id
	chanmap {1 0} {0 9}
	</PRE>

<H2>Transpose</H2>

	Let us create a filter that transposes by 12 half-tones
	(one octave) notes played on device 1, channel 0 (keyboard) and
	sends them on device 0 channel 2 (sound-module). First
	we create the input filter:
	<PRE>
	filtnew mypiano			# define filter 'mypiano'
	songsetcurfilt mypiano		# make 'mypiano' the current filter
	</PRE>
	then, we add a channel-map and a key-map rule to the filter:
	<PRE>
	filtchanmap mypiano {1 0} {0 2}
	filtkeymap mypiano {1 0} {0 2} 0 127 12
	</PRE>
	both rules are necessary. Note events are handled by 
	the key-rule and other events (controllers) fall trough
	the channel-rule. Arguments 4 and 5 to <TT>filtkeymap</TT>
	give the note range that will be transposed 
	(from 0 to 127, i.e. the whole keyboard)
	and the 6-th argument give the number of half-tones 
	(12, one octave).
	
<H2>Keyboard splits</H2>

	In the same way we can create a keyboard-split with two
	key-rules and two channel-rules. 
	Let us split the
	keyboard in two parts (left and right) on note 64 (note E3),  in
	the middle. 
	Notes on the left part 	will be routed to
	channel 3  of the sound module and notes on the right
	part will be routed to channel 2 of the sound module.
	<PRE>
	filtnew mysplit
	filtchanmap mysplit {1 0} {0 2}
	filtkeymap mysplit {1 0} {0 2} 0 63 0
	filtchanmap mysplit {1 0} {0 3}
	filtkeymap mysplit {1 0} {0 3} 64 127 0
	songsetcurfilt mysplit
	</PRE>
	<P>
	Defining filters seem quite tedious, however it's possible
	to define procedures that do the same in a very simpler way.

<A name="chan"></A>
<H1>Channels</H1>

	Because midish handles multiple devices, instead of
	using midi-channels, it uses device/midi-channel pairs.
	We'll often refer by <I>channel</I>
	the device/midi-channel pair. As we have seen, channels
	are handled by two-item lists, like this:
	<PRE>
	{0 1}			# device 0, midi-channel 1
	</PRE>
	Channels can also be named, as follows:
	<PRE>
	channew mybass {0 1}
	</PRE>
	this defines a named-channel <TT>drums</TT> that can
	be used instead of the <TT>{0 1}</TT> pair.
	
<H2>Channel configuration</H2>

	Since a channel represents a musical instrument, 
	midish allow us to attach to the channel definition 
	basic configuration. For instance;
	to select patch 34 on channel drums, we attach
	a "program change" event:
	<PRE>
	chanconfev mybass { pc mybass 32 }
	</PRE>
	the list-argument gives the event to attach to the channel.
	Such events are sent to the output when performance starts,
	for instance just before playback starts. This approach avoids
	flooding midi devices when playback starts.
	
	In the same way, to set the volume (controller 7) 
	of this channel to 120:
	<PRE>
	chanconfev mybass { ctl mybass 7 120 }
	</PRE>
	If several events of the same type are attached, 
	the just the last one is kept. So, to change
	the volume to 125, we just need:
	<PRE>
	chanconfev mybass { ctl mybass 7 125 }
	</PRE>
	
<A name="time"></A>
<H1>Time structure</H1>

	<P>
	In midish, time is split in <I>measures</I>. Each measure
	is split in <I>beats</I> and each beat is split in 
	<I>tics</I>. The <I>tic</I> is the fundamental
	time unit in midish. Duration of tics is fixed
	by the <I>tempo</I>. By default midish uses:
		<UL>
		<LI>24 tics per beat
		<LI>4 beats per measure
		<LI>120 beats per minute
		</UL>
	From the musical point of view, a beat often corresponds to
	a quarter note, to an eight note etc... 
	By default 
	an unit note corresponds to 96 tics, thus by default
	one beat corresponds to one quarter note, i.e. 
	the time signature is 4/4.
	
	
<H2>Metronome</H2>

	In order to "hear" time, we can use a metronome. It is
	used only in play and record modes. It produces
	a click sound on every beat. Let us start the metronome:
	<PRE>
	metroswitch 1		# switch the metronome on
	songplay		# start playback
	</PRE>
	The metronome has to kind of clocks.
	<UL>
	<LI> hi-click: on the first beat of the measure
	<LI> lo-click: on the other beats.
	</UL>
	The click-sound can be configured by giving a couple 
	of note-on events, as follows:
	<PRE>
	metroconf { non {0 9} 48 127 } { non {0 9} 64 100}}
	</PRE>
	this configures the hi-click with note 48, velocity 127 on
	device 0, channel 9 and the lo-click with note 64, velocity 100
	on device 0, channel 9.
	

<H2>Time signature changes</H2>

	Time signature changes are achieved by inserting or
	deleting measures. For instance let us start
	a song with time signature of 4/4 (at measure 0) and
	change the time signature to 6/8 at measure 2 during
	5 measures:
	<PRE>
	songtimeins 0 2 4 4	# 4/4 at measure 0 during 2 measures
	songtimeins 2 5 6 8	# 8/6 at measure 2 during 5 measures
	metroswitch 1		# switch the metronome on
	songplay		# test it
	</PRE>
	Now we can suppress measure number 2 (the first 6/8 measure)
	<PRE>
	songtimerm  2 1		# remove 1 measure starting a measure 2
	metroswitch 1		# switch the metronome on
	songplay		# test it
	</PRE>
	
<H2>Tempo changes</H2>
	
	Tempo changes are achieved simply by giving the measure
	number and the tempo value in beats per minute. For
	instance, the following changes tempo on measure 0
	to 100 beats per minute and on measure 2 to 180 beats 
	per minute.
	<PRE>
	songsettempo 0 100
	songsettempo 2 180
	</PRE>


<H2>Moving in the song</H2>

	We can select the current position in the song to
	measure number 3 as follows:
	<PRE>
	songsetcurpos 3
	</PRE>
	This will make <TT>songrecord</TT> and <TT>songplay</TT>
	start at this particular position instead of measure
	number 0.
	
<A name="track"></A>
<H1>Tracks</H1>
	
	<P>
	A track is a piece of music, namely an ordered in time list 
	of midi events. In play mode, midish play simultaneously
	all defined tracks, in record-mode it plays all defined tracks
	and records the current track.
	
	<P>
	Tracks aren't binded to any particular device/channel; a track
	can contain midi data from any device/channel. A track can have its 
	<I>current filter</I>; in this case, midi events
	are passed through that filter before being recorded. If the
	track has no current filter, then the song current
	filter is used instead. If there is neither track current
	filter nor song current filter, then midi events
	from all devices are recorded as-is.

<H2>Recording track without a filter</H2>

	<P>
	Let us define a track and record data
	as-is from all midi devices.
	<PRE>
	tracknew mytrack
	songsetcurtrack mytrack
	songrecord
	</PRE>
	tracks are played as follows:
	<PRE>
	songplay
	</PRE>
	However, with the above configuration this will not
	work as expected because events from the input
	keyboard (device number 1) will be recorded as-is and then 
	sent back to the device number 1 instead of being sent
	to the sound module (device number 0).
	
<H2>Recording track with a filter</H2>

	Let us create a filter and use it to
	record to the above track:
	<PRE>
	filtnew mypiano
	filtchanmap mypiano {1 0} {0 0}		# dev1/chan0 -> dev0/chan0
	tracksetcurfilt mypiano
	trackrecord
	</PRE>
	
<H2>Basic editing of a track</H2>

	<P>
	Most track editing functions in midish take at least the
	following arguments:
	<UL>
	<LI> start measure
	<LI> number of measures
	<LI> precision/quantum (in tics).
	</UL>
	For instance let us blank measure number 3 of
	track <TT>mypiano</TT>:
	<PRE>
	trackblank mypiano 3 1 (96 / 16)
	</PRE>
	the 3-rd argument set the precision to sixteenth note
	(assuming 96 tics per unit note). This
	means that notes starting just before the 3-rd measure will
	be suppressed. This is useful, because often recorded notes
	doesn't start exactly on the measure boundary. The precision
	argument let you edit a track that is not quantised.

	<P>
	In a similar way, one can cut a piece of a track, 
	for instance let us cut 2 measures starting
	at measure number 5:
	<PRE>
	trackcut mypiano 5 2 (96 / 16)
	</PRE>
	
	<P>
	Now, let us insert 2 blank measure at
	measure number 3:
	<PRE>
	trackinsert mypiano 3 2 (96 / 16)
	</PRE>
	
	<P>
	A track portion ca be copied into
	another track as follows:
	<PRE>
	trackcopy mypiano 3 2 mypiano2 5 (96 / 16)
	</PRE>
	this will copy 2 measures starting from measure
	number 3 into (the already existing) track <TT>mypiano2</TT>
	at measure 5.
	

<H2>Track quantisation</H2>

	In order to make a track sound more "precise", 
	on can regularise it by rounding note-positions
	to the nearest round position. The following
	will quantise 4 measures starting at measure number
	3 by rounding notes to the nearest quarter notes.
	<PRE>
	trackquant mypiano 3 4 (96 / 4) 75
	</PRE>
	The last arguments gives the percent of quantisation.
	100% means full quantisation and 0% leans no
	quantisation at all. This is useful because full quantisation
	often sound to regular especially on acoustic patches.
	

<H2>Checking a track</H2>

	It is possible that a midi device transmits 
	bogus midi data. In principle when a filter is
	used data is rewritten and contains no anomalies.
	The following scans the track and removes bogus notes
	and unused controller events:
	<PRE>
	trackcheck mytrack
	</PRE>
	This function can be useful to remove 
	nested notes when a track is recorded twice (or more) 
	without being erased.

<A name="info"></A>
<H1>Obtaining information</H2>

	<P>
	The following functions gives some informations
	about midish objects:
	<PRE>
	songinfo
	chaninfo mydrums	# about channel 'mydrums'
	filtinfo myfilt		# about filter 'myfilt'
	</PRE>
	
	<P>
	Objects can be listed as follows:
	<PRE>
	print [tracklist]
	print [chanlist]
	print [filtlist]
	print [devlist]
	</PRE>

	<P>
	Current values can be obtained as follows:
	<PRE>
	print [songgetunit]		# tics per unit note
	print [songgetcurpos]		# print current position
	print [songgetcurfilt]		# current filter
	print [songgetcurtrack]		# current track
	print [trackgetcurfilt mypiano]	# current filter of track 'mypiano'
	</PRE>

	<P>
	The device and the midi channel of a channel definition
	can be obtained as follows:
	<PRE>
	print [changetnum mydrums]	# print midi chan number
	print [changetdev mydrums]	# print device number
	</PRE>
	
	<P>
	To check if object exists:
	<PRE>
	print [chanexists]
	print [filtexists]
	print [trackexists]
	</PRE>
	this will print 1 if the corresponding object exists
	and 0 otherwise.
	

<A name="save"></A>
<H1>Saving and loading songs</H1>

	<P>
	A song can be saved into a file. All channel definitions, 
	filters, tracks, their properties, 
	and values of the current track, current 
	filter will be saved by:
	<PRE>
	songsave "myfile"
	</PRE>
	In a similar way, the song can be load from a file 
	as follows:
	<PRE>
	songload "myfile"
	</PRE>
	
	<P>
	Note that the "local settings" (like device configuration,
	metronome settings) are not saved. 
	
<A name="export"></A>
<H1>Import/export standard MIDI files</H1>

	<P>
	Standard MIDI files type 0 or 1 can be imported. Each
	track in the standard midi file corresponds to a track in midish.
	Tracks are named <TT>trk00</TT>, <TT>trk01</TT>, ... 
	All midi events are binded to device number 0. Only the following
	meta events are handled:
		<UL>
		<LI> tempo changes
		<LI> time signature changes
		</UL>
	all meta-events are removed from the "voice" tracks and
	are moved into the midish's meta-track. Finally tracks
	are checked for anomalies. Example:
	<PRE>
	songimportsmf "mysong.mid"
	</PRE>
	
	<P>
	Midish songs can be exported into standard midi files.
	Tempo changes and time signature changes are exported
	to a meta-track (first track of the midi file). Each
	channel definition is exported as a track containing
	the channel configuration events. Voice tracks
	are exported as is in separate tracks. Note that device 
	numbers of midi events are not stored in the midi file
	because the file format does not allow this.	
	Example:
	<PRE>
	songexportsmf "mysong.mid"
	</PRE>
	
<A name="language"></A>
<H1>The interpreter's language</H1>

	<P>
	In order to achieve any simple task with midish, we often have
	to write several long statements. In order to make midish easier
	to use we can use variables and/or define our own procedures.
	For more details about the interpreted language, please
	refer to the <A href="manual.html">manual</A>.

<H2>Defining simple procedures</H2>

	<P>
	For instance, let
	us create a procedure named "<TT>i</TT>" that just replaces
	<TT>songidle</TT> in order to avoid typing its name.
	<PRE>
	proc i { songidle; }
	</PRE>
	The <TT>proc</TT> keyword is followed by the procedure
	name and then follows a list of statements between
	braces. In a similar way can define the following
	procedures:
	<PRE>
	proc p {
		metroswith 0		# turn off metronome
		songplay		# start playback
	}
	
	proc r {
		metroswitch 1		# turn on metronome
		songrecord		# start recording
	}
	</PRE>
	
	<P>
	Procedures can take arguments. 
	For instance, let us define a procedure named <TT>nf</TT> 
	that creates a new filter and then makes it the current filter:
	<PRE>
	proc nf filtname {
		filtnew $filtname
		songsetcurfilt $filtname
	}
	</PRE>
	After the name of the procedure follows the argument names list
	that can be arbitrary identifiers. The value of the arguments
	is obtained by preceding the variable name by the dollar
	sign ("$"). We can use the above procedure to create a filter:
	<PRE>
	nf myfilt
	</PRE>
	
	A lot of similar procedures are defined in the
	sample <TT>midishrc</TT> file, shipped in the source
	tar-ball. The make midish easy to use, most of
	the usual tasks can be performed with only 2 or
	three character statements.
	
<A name="example"></A>
<H1>Example session</H1>

<HR>
<SMALL><EM>
Copyright (c) 2003-2005 Alexandre Ratchov	<BR>
Last updated mar 11, 2005 	
</EM></SMALL>
	

</BODY>
</HTML>
