<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>midish - tutorial</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</HEAD>
<BODY bgcolor="white" text="black" link="blue" vlink="navy">

<H1>Table of contents</H1>
<P>
<UL>
<LI><A href="#intro">Introduction</A>
<LI><A href="#dev">Device setup</A>
<LI><A href="#filt">Filtering/routing</A>
<LI><A href="#chan">Channels</A>
</UL>


<A name="intro"></A>
<H1>Introduction</H1>

	<P>
	Midish is a MIDI sequencing and filtering tool. 
	
	It is implemented as a sequencing engine and a 
	command-line interpreter.
	
	Once midish started, the interpreter prompts
	for commands. One can configure midi-devices, 
	create tracks, define channel/controller mappings,
	route events from one device to another, playback, 
	record etc.

	To start midish, just type:
	<PRE>
	midish
	</PRE>
	
	Now you can issue commands, for instance:
	<PRE>
	print "hello world"
	</PRE>

<A name="dev"></A>
<H1>Device setup</H1>

	In midish, midi-devices are numbered from 0 to 15.
	Each midi-device has its "slot number". For instance, 
	suppose	that one have:

	<UL>
	<LI>
		a midi sound module known as
		<TT>/dev/rmidi3</TT> by the operating
		system (or <TT>/dev/snd/midiC3D0</TT> on Linux)
	<LI>
		a midi keyboard known as
		<TT>/dev/rmidi2</TT> by the operating
		system (or <TT>/dev/snd/midiC2D0</TT> on Linux)
	</UL>
	
	To configure the module as device number 0 and
	the keyboard as device number 1, type:
	<PRE>
	devattach 0 "/dev/rmidi3"
	devattach 1 "/dev/rmidi2"
	</PRE>
	
	<P>
	<STRONG>Important note</STRONG>
	We strongly suggest that the main sound module (most used)
	be attached as device number 0. This makes easier
	to import/export music from systems with different configurations.

	<P>
	Now, let's check that the sound module is properly configured, 
	for instance we can play the demo song. Put your module in 
	general midi mode and type:
	<PRE>
	songload "sample.sng"
	songplay
	</PRE>
	
	Once your are satisfied by your setup,
	you can put the "<TT>devattach</TT>" commands
	in your <TT>$HOME/.midishrc</TT>. They will be
	automaticaly executed the next time you run midish.
	
<A name="filt"></A>
<H1>Filtering/routing</H1>

	<P>
	Midish supports midi filtering. That means, that you can
	define a "filter" that transforms input events before
	sending them to the output. Currently a filter can mainly be
	used to:
	<UL>
	<LI>
	route events from one device to another one
	<LI>
	map a controller to another one
	<LI>
	make keyboard splits
	<LI>
	etc...
	</UL>

	<P>
	If no filters are defined, in performance mode, input is send 
	to the output as-is. Filters are defined as follows:
	<PRE>
	filtnew myfilt			# define filter 'myfilt'
	</PRE>
	initially the filter is empty and will send input to output
	as-is.
	Several filters can be defined, however only the
	<EMPH>current filter</EMPH> will run in performance
	mode. The current filter is set as follows:
	<PRE>
	songsetcurfilt myfilt		# make 'myfilt' the current filter
	</PRE>
	
	Once the filter is created, filtering rules can be added
	using <TT>filtdevmap, filtchanmap, filtctlmap, filtkeymap</TT>.
	Rules can be listed with <TT>filtinfo</TT>. Currently it
	is not yet possible to modify/remove individual rules, the
	only way is to remove all rules with <TT>filtreset</TT>.
	
<H2>Device redirections</H2>

	Let us define a filter and use it to route events from
	device number 1 (the midi keyboard) to device number 0
	(the sound module). First we define the filter and
	make it the current filter:
	<PRE>
	filtnew mydevmap		# define filter 'mydevmap'
	songsetcurfilt mydevmap		# make 'mydevmap' the current filter
	</PRE>
	the we define a "device map" rule:
	<PRE>
	filtdevmap mydevmap 1 0		# route device 1 -> device 0
	</PRE>
	Finally, we can test the filter, by starting performance mode:
	<PRE>
	songidle
	</PRE>
	The filter will run until "Enter" is hit on the console.
	
<H2>Channel maps</H2>

	Let us define a filter that routes events from
	device 1, channel 0 (first channel of the keyboard) to
	device 0, channel 9 (default drum channel of the sound module).
	First, we define the filter:
	<PRE>
	filtnew mydrums			# define filter 'mydrums'
	songsetcurfilt mydrums		# make 'mydevmap' the current filter
	</PRE>
	then we define a rule that maps device 1 channel 0 to 
	device 0 channel 9:
	<PRE>
	filtchanmap mydrums {1 0} {0 9}
	</PRE>
	The device/channel pair is in braces. The first <TT>{1 0}</TT>
	is the input device/channel and <TT>{0 9}</TT> is the output channel.
	Finally we try the filter:
	<PRE>
	songidle
	</PRE>
	Playing on channel 0 of the keyboard will make
	sound channel 9 of the sound-module.

<H2>Controller maps</H2>

	Let us continue with the later filter. Now 
	we will add a new rule that maps the modulation wheel (controller 1)
	of device 1, channel 0 (first channel of the keyboard) to
	the expression controller (number 11) of device 0, channel 9 (the
	default drums channel of the sound module).
	<PRE>
	filtctlmap mydrums {1 0} {0 9} 1 11
	</PRE>
	the first three arguments are the name of the filter, 
	the input and the output device/channel pair. The 4-th
	argument is the controller number on the input (1 = modulation)
	and the 5-th the controller number on the output (11 = expression).
	Rules of the filter can be listed on the console as follows:
	<PRE>
	filtinfo mydrums
	</PRE>
	normally this prints something like:
	<PRE>
	ctlmap {1 0} {0 9} 1 11 id
	chanmap {1 0} {0 9}
	</PRE>

<H2>Transpose</H2>

	Let us create a filter that transposes by 12 half-tones
	(one octave) notes played on device 1, channel 0 (keyboard) and
	sends them on device 0 channel 2 (sound-module). First
	we create the input filter:
	<PRE>
	filtnew mypiano			# define filter 'mypiano'
	songsetcurfilt mypiano		# make 'mypiano' the current filter
	</PRE>
	then, we create a add a channel-map and a key-map rule to the filter:
	<PRE>
	filtchanmap mypiano {1 0} {0 2}
	filtkeymap mypiano {1 0} {0 2} 0 127 12
	</PRE>
	both rules are necessary. Note events are handled by 
	the key-rule and other events (controllers) fall trough
	the channel-rule. Arguments 4 and 5 to <TT>filtkeymap</TT>
	give the note range that will be transposed 
	(from 0 to 127, ie the whole keyboard)
	and the 6-th argument give the number of half-tones 
	(12, one octave).
	
<H2>Keyboard splits</H2>

	In the same way we can create a keyboard-split with two
	key-rules and two channel-rules. 
	Let us splits the
	keyboard in two parts (left and right) on note 64 (note E3),  in
	the middle. 
	Notes on the left part 	will be routed to
	channel 3  of the sound module and notes on the right
	part will be routed to channel 2 of the sound module.
	<PRE>
	filtnew mysplit
	filtchanmap mysplit {1 0} {0 2}
	filtkeymap mysplit {1 0} {0 2} 0 63 0
	filtchanmap mysplit {1 0} {0 3}
	filtkeymap mysplit {1 0} {0 3} 64 127 0
	songsetcurfilt mysplit
	</PRE>
	<P>
	It defining filters seem quite tedious, however it's possible
	to define procedures that do the same in a very simpler way.

<A name="chan"></A>
<H1>Channels</H1>

	Because midish handles multiple devices, enstead of
	using midi-channels, it uses device/midi-channel pairs.
	We'll often refer by <EMPH>channel</EMPH>
	the device/midi-channel pair. As we have seen, channels
	are handles by two-item lists, like this:
	<PRE>
	{0 1}			# device 0, midi-channel 1
	</PRE>
	Channels can also be named, is follows:
	<PRE>
	channew mybass {0 1}
	</PRE>
	this defines a named-channel <TT>drums</TT> that can
	be used instead of the <TT>{0 1}</TT> pair.
	
<H2>Channel configuration</H2>

	Since a channel represents a musical instrument, 
	midish allow to attach to the channel definition 
	basic configuration. For instance;
	to select patch 34 on channel drums, we attach
	a "program change" event:
	<PRE>
	chanconfev mybass { pc mybass 32 }
	</PRE>
	the list-argumet gives the event to attach to the channel.
	Such events are sent to the output when performace starts,
	for instance juste before playback starts. This approach avoids
	flooding midi devices when playback starts.
	
	In the same way, to set the volume (controller 7) 
	of this channel to 120:
	<PRE>
	chanconfev mybass { ctl mybass 7 120 }
	</PRE>
	If seferal events of the same type are attached, 
	the just the last one is kept. So, to change
	the volume to 125, we just need:
	<PRE>
	chanconfev mybass { ctl mybass 7 125 }
	</PRE>
	
<A name="track"></A>
<H1>Tracks</H1>
	
	A track is a piece of music, namely a ordered list 
	of midi events. In play mode, midish play simultaneously
	all the trach, in record-mode it plays all the tracks an
	records the current track.

</BODY>
</HTML>
