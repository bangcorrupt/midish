#
# midi devices config
#
#devattach 0 "/dev/rmidi4"
#devattach 1 "/dev/rmidi3"

#
# set the current input channel
#
proc ci input {
	songsetcurinput $input
	let filt = [songgetcurfilt]
	if $filt {
		let chan = [filtgetcurchan $filt]
		if $chan {
			chansetcurinput $chan $input
		}
	}
	let chan = [songgetcurchan]
	if $chan {
		chansetcurinput $chan $input
	}
}

#
# set the current channel
#
proc cc chan {
	songsetcurchan $chan
	if $chan {
		songsetcurinput [changetcurinput $chan]
	}
}

#
# set the current filt
#
proc cf filt { 
	songsetcurfilt $filt
	if $filt {
		cc [filtgetcurchan $filt]
	}
}

#
# set the current track
#
proc ct track { 
	songsetcurtrack $track
	if $track {
		cf [trackgetcurfilt $track]
	}
}

#
# create a channel and a filter
#
proc nc name chan {
	channew $name $chan
	chansetcurinput $name [songgetcurinput]
	songsetcurchan $name
	filtnew $name 
	filtsetcurchan $name $name
	filtchanmap $name [changetcurinput $name] $name
	songsetcurfilt $name
}

#
# create a new filter 
#
proc nf filt { 
	filtnew $filt
	let chan = [songgetcurchan]
	if $chan {
		filtsetcurchan $filt $chan
		filtchanmap $filt [changetcurinput $chan] $chan
	}
	songsetcurfilt $filt
}


#
# create a new track 
#
proc nt name { 
	tracknew $name 
	tracksetcurfilt $name [songgetcurfilt]
	songsetcurtrack $name
}


#
# some filter rules
#
proc ctldrop ic {
	let filt =  [songgetcurfilt]
	let ochan = [filtgetcurchan  $filt]
	let ichan = [changetcurinput $dest]
	filtctldrop [songgetcurfilt] $i $ic
}
proc ctlmap ic oc {
	let filt =  [songgetcurfilt]
	let chan =  [filtgetcurchan $filt]
	let input = [changetcurinput $chan]
	filtctlmap $filt $input $chan $ic $oc
}
proc transpose o halftones {
	let filt =  [songgetcurfilt]
	let chan =  [filtgetcurchan $filt]
	let input = [changetcurinput $chan]
	filtkeymap $filt $input $chan  0 127 $halftones
}


#
# do nothing, just echo trough the configuration of the current track
#
proc i  {
	songidle;
}

#
# play the song
#
proc p  {
	metroswitch 0;
	songplay;
	shut;
}

#
# record a track while playing the song, start 1 measure before
# the current position
#
proc r  { 
	metroswitch 1; 
	let curpos = [songgetcurpos]
	if ($curpos >= 1) {
		songsetcurpos $curpos - 1
	}
	songrecord;
	songsetcurpos $curpos	
	shut; 
}

#
# print the list of tracks, channels and filters, etc
#
proc l  {
	songinfo
}

#
# change current position
#
proc g measure {
	songsetcurpos $measure
}

#
# set note quantum
#
proc n denom {
	songsetcurquant [songgetunit]/$denom
} 

#
# quantise
#
proc q amount rate {
	trackquant [songgetcurtrack] [songgetcurpos] $amount $rate [songgetcurquant]
} 

#
# cut a piece of a track
#
proc cut amount {
	trackcut [songgetcurtrack] [songgetcurpos] $amount [songgetcurquant]
}


#
# clear a piece of a track
#
proc clr amount {
	trackblank [songgetcurtrack] [songgetcurpos] $amount [songgetcurquant] {}
}

#
# insert measures in a track
#
proc ins amount {
	trackinsert [songgetcurtrack] [songgetcurpos] $amount [songgetcurquant]
}

#
# copy measures in a track
#
proc copy amount where {
	let track = [songgetcurtrack]
	let from = [songgetcurpos]
	trackcopy $track $from $amount $track ($where + $from) [songgetcurquant] {}
}

#
# cut a piece of the song
#
proc gcut amount {
	let pos = [songgetcurpos] 
	for i in [tracklist] {
		trackcut $i $pos $amount [songgetcurquant]
	}
}

#
# insert measures in the song
#
proc gins amount {
	let pos = [songgetcurpos] 
	for i in [tracklist] {
		trackinsert $i $pos $amount [songgetcurquant]
	}
}

#
# copy a piece of the song
#
proc gcopy amount where {
	let from = [songgetcurpos]
	for track in [tracklist] {
		trackcopy $track $from $amount $track ($where + $from) [songgetcurquant] {}
	}
}


#
# mute a track
#
proc mute track {
	tracksetmute $track 1
}

#
# unmute a track
#
proc unmute track {
	tracksetmute $track 0
}

#
# unmute all tracks
#
proc nomute {
	for i in [tracklist] {
		tracksetmute $i 0
	}
}

#
# mute all tracks but current
#
proc solo {
	for i in [tracklist] {
		tracksetmute $i ($i != [songgetcurtrack])
	}
}

#
# save the song
#
proc save filename {
	songsave $filename
}

#
# load a song
#
proc load filename {
	songload $filename
}

#
# export a song in a .mid
#
proc export filename {
	songexportsmf $filename
}

#
# import a song from a .mid
#
proc import filename {
	songimportsmf $filename
}

#
# change tempo a current position
#
proc tempo beat_per_measure {
	songsettempo [songgetcurpos] $beat_per_measure
}

#
# insert measures in the meta-track
#
proc timeins amount numerator denominator {
	songtimeins [songgetcurpos] $amount $numerator $denominator
}

#
# remove measures from the meta-track
#
proc timerm amount {
	songtimerm [songgetcurpos] $amount
}

#
# turn on general midi (send sysex)
#
proc gmon devnum {
	sendraw $devnum { 0xF0 0x7E 0x7F 0x09 0x01 0xF7 }
}

#
# configure an instrument for a given general midi patch
#
proc gmp patch {
	let chan = [songgetcurchan]
	chanconfev $chan { pc $chan ($patch - 1) }
}


#
# XV-2020 specific macros
#
# configures a instrument with the given bank/patch or bank rhythm
# bank 1,2,3,4 corresponds to preset A,B,C,D
# patches/rhythmes are counted from 1 to 128
#
proc xvp bank patch {
	let chan = [songgetcurchan]
	chanconfev $chan { ctl $chan 0  87 } 
	chanconfev $chan { ctl $chan 32 (64 + $bank - 1) } 
	chanconfev $chan { pc  $chan ($patch  - 1) }
}
proc xvr bank rhythm { 
	let chan = [songgetcurchan]
	chanconfev $chan { ctl $chan 0  86 } 
	chanconfev $chan { ctl $chan 32 (64 + $bank - 1) } 
	chanconfev $chan { pc  $chan ($rhythm - 1) }
}

#
# generate a sysex message that set parameter on 
# address (a0,a1,a2,a3) to val
#
proc xvparam a0 a1 a2 a3 val {
	return {  							\
		0xf0 0x41 0x7f 0x00 0x10 0x12 $a0 $a1 $a2 $a3 $val	\
		128 - ($a0 + $a1 + $a2 + $a3 + $val) % 128		\
		0xf7 }
}

#
# controllers config
#
proc mod    v { let c = [songgetcurchan]; chanconfev $c {ctl $c 1  $v}; }
proc breath v { let c = [songgetcurchan]; chanconfev $c {ctl $c 2  $v}; }
proc vol    v { let c = [songgetcurchan]; chanconfev $c {ctl $c 7  $v}; }
proc bal    v { let c = [songgetcurchan]; chanconfev $c {ctl $c 8  $v}; }
proc pan    v { let c = [songgetcurchan]; chanconfev $c {ctl $c 10 $v}; }
proc reverb v { let c = [songgetcurchan]; chanconfev $c {ctl $c 91 $v}; }
proc chorus v { let c = [songgetcurchan]; chanconfev $c {ctl $c 93 $v}; }

