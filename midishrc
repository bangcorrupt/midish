#
# midi devices config
#
#dnew 0 "/dev/rmidi4" rw
#dnew 1 "/dev/rmidi3" rw

#
# create a channel and a filter
#
proc ni name chan {
	ct nil
	cnew $name $chan
	fnew $name 
	fmap {any [geti]} {any $name}
}

#
# some filter rules
#
proc ctldrop ctlno {
	fmap {ctl [geti] $ctlno} {none}
}
proc ctlmap ic oc {
	fmap {ctl [geti] $ic} {ctl [getc] $oc}
}
proc transp plus {
	let i = [geti]
	let o = [getc]
	let lo = 0;
	let hi = 127;
	funmap {} {note $i}
	if ($hi + $plus > 127) {
		let hi = $hi - $plus
	}
	if ($lo + $plus < 0) {
		let lo = $lo - $plus
	}
	fmap {note $i {$lo $hi}} {note $o {$lo + $plus $hi + $plus}}
}

#
# quantise
#
proc q rate {
	tquant $rate
} 

#
# copy current selection 'offset' measures forward
#
proc copy offset {
	tcopy [gett] ([getpos] + $offset)
}

#
# cut a piece of the song
#
proc gcut amount {
	let track = [gett];
	for i in [tlist] {
		ct $i 
		tcut $amount
	}
	ct $track
}

#
# insert measures in the song
#
proc gins amount {
	let track = [gett];
	for i in [tlist] {
		ct $i
		tins $amount
	}
	ct $track
	sel $amount
}

#
# copy a piece of the song 'where' measures forward
#
proc gcopy where {
	let track = [gett];
	for i in [tlist] {
		ct $i
		tcopy $i ([getpos] + $offset)
	}
	ct $track
}


#
# unmute all tracks
#
proc nomute {
	for i in [tlist] {
		unmute $i
	}
}

#
# mute all tracks but current
#
proc solo {
	for i in [tlist] {
		mute $i
	}
	unmute [gett]
}

#
# turn on general midi (send sysex)
#
proc gmon devnum {
	xnew gmon
	xadd $devnum { 0xF0 0x7E 0x7F 0x09 0x01 0xF7 }
}

#
# configure an instrument for a given general midi patch
#
proc gmp patch {
	caddev $chan { pc [getc] ($patch - 1) }
}

#
# XV-2020 specific macros
#
# configures a instrument with the given bank/patch or bank rhythm
# bank 1,2,3,4 corresponds to preset A,B,C,D
# patches/rhythmes are counted from 1 to 128
#
proc xvp bank patch {
	caddev { xpc [getc] ($patch - 1) (87 * 128 + (64 + $bank - 1)) }
}
proc xvr bank patch { 
	caddev { xpc [getc] ($patch - 1) (86 * 128 + (64 + $bank - 1)) }
}

#
# generate a sysex message that set parameter on 
# address (a0,a1,a2,a3) to val
#
proc xvparam a0 a1 a2 a3 val {
	return {  							\
		0xf0 0x41 0x7f 0x00 0x10 0x12 $a0 $a1 $a2 $a3 $val	\
		128 - ($a0 + $a1 + $a2 + $a3 + $val) % 128		\
		0xf7 }
}

#
# controllers config
#
proc vol    val { caddev {ctl [getc] 7  $val}; }
proc bal    val { caddev {ctl [getc] 8  $val}; }
proc pan    val { caddev {ctl [getc] 10 $val}; }
proc reverb val { caddev {ctl [getc] 91 $val}; }
proc chorus val { caddev {ctl [getc] 93 $val}; }

#
# set RPN/NRPN to the given value for the current chan
#
proc rpn  addr val {
	caddev {rpn [getc] $addr $val}
}
proc nrpn addr val { 
	caddev {nrpn [getc] $addr $val}
}
