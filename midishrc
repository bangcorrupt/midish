#
# midi devices config
#
#devattach 0 "/dev/rmidi4" rw
#devattach 1 "/dev/rmidi3" rw

#
# create a channel and a filter
#
proc ni name chan {
	ct nil
	filtnew $name 
	channew $name $chan
	filtchanmap $name [geti] $name
}

#
# create a new filter 
#
proc nf filt { 
	filtnew $filt
}

#
# create a new track 
#
proc nt name { 
	tracknew $name 
}

#
# some filter rules
#
proc ctldrop ic {
	let i = [geti]
	let c = [getc]
	filtevmap [songgetcurfilt] {ctl $i $ic} {none}
}
proc ctlmap ic oc {
	let i = [geti]
	let o = [getc]
	filtevmap [songgetcurfilt] {ctl $i $ic} {ctl $o $oc}
}
proc transpose plus {
	let i = [geti]
	let o = [getc]
	#let lo = 0;
	#let hi = 127;
	#filtevunmap [songgetcurfilt] {} {note $i}
	#if ($hi + $plus > 127) {
	#	let hi = $hi - $plus
	#}
	#if ($lo + $plus < 0) {
	#	let lo = $lo - $plus
	#}
	#filtevmap [songgetcurfilt] {note $i {$lo $hi}} {note $c {$lo + $plus $hi + $plus}}
	filtnokeymap [songgetcurfilt] $o 0 127
	filtkeymap   [songgetcurfilt] $i $o 0 127 $plus
}

#
# set note quantum
#
proc n denom {
	setq [getunit] / $denom
} 

#
# quantise
#
proc q rate {
	trackquant [gett] [getpos] [getlen] $rate [getq]
} 

#
# cut the given number of measures from the current 
# position on the current track
#
proc cut amount {	 
	trackcut [songgetcurtrack] [songgetcurpos] $amount [songgetcurquant]
}

#
# insert measures in a track, and select them
#
proc ins amount {
	trackinsert [songgetcurtrack] [songgetcurpos] $amount [songgetcurquant]
	songsetcurlen $amount
}

#
# clear a piece of a track
#
proc clr {
	trackblank [songgetcurtrack] [songgetcurpos] [songgetcurlen] [songgetcurquant] {}
}

#
# copy current selection 'where' measures forward
#
proc copy where {
	let track = [songgetcurtrack]
	let from = [songgetcurpos]
	let len = [songgetcurlen]
	trackcopy $track $from $len $track ($where + $from) [songgetcurquant] {}
}

#
# cut a piece of the song
#
proc gcut amount {
	let pos = [songgetcurpos] 
	let quant = [songgetcurquant]
	for i in [tracklist] {
		trackcut $i $pos $amount $quant
	}
}

#
# insert measures in the song
#
proc gins amount {
	let pos = [songgetcurpos] 
	let quant = [songgetcurquant]
	for i in [tracklist] {
		trackinsert $i $pos $amount $quant
	}
	songsetcurlen $amount
}

#
# copy a piece of the song 'where' measures forward
#
proc gcopy where {
	let from = [songgetcurpos]
	let amount = [songgetcurlen] 
	let quant = [songgetcurquant]
	for track in [tracklist] {
		trackcopy $track $from $amount $track ($where + $from) $quant {}
	}
}


#
# unmute all tracks
#
proc nomute {
	for i in [tracklist] {
		unmute $i
	}
}

#
# mute all tracks but current
#
proc solo {
	unmute [gett]
	for i in [tracklist] {
		if ($i != [gett]) {
			mute $i
		}
	}
}

#
# insert measures in the meta-track
#
proc timeins amount numerator denominator {
	songtimeins [songgetcurpos] $amount $numerator $denominator
}

#
# remove measures from the meta-track
#
proc timerm amount {
	songtimerm [songgetcurpos] $amount
}

#
# turn on general midi (send sysex)
#
proc gmon devnum {
	sendraw $devnum { 0xF0 0x7E 0x7F 0x09 0x01 0xF7 }
}

#
# configure an instrument for a given general midi patch
#
proc gmp patch {
	let chan = [songgetcurchan]
	chanconfev $chan { pc $chan ($patch - 1) }
}

#
# XV-2020 specific macros
#
# configures a instrument with the given bank/patch or bank rhythm
# bank 1,2,3,4 corresponds to preset A,B,C,D
# patches/rhythmes are counted from 1 to 128
#
proc xvp bank patch {
	let chan = [songgetcurchan]
	chanconfev $chan { xpc $chan ($patch - 1) (87 * 128 + (64 + $bank - 1)) }
}
proc xvr bank patch { 
	let chan = [songgetcurchan]
	chanconfev $chan { xpc $chan ($patch - 1) (86 * 128 + (64 + $bank - 1)) }
}

#
# generate a sysex message that set parameter on 
# address (a0,a1,a2,a3) to val
#
proc xvparam a0 a1 a2 a3 val {
	return {  							\
		0xf0 0x41 0x7f 0x00 0x10 0x12 $a0 $a1 $a2 $a3 $val	\
		128 - ($a0 + $a1 + $a2 + $a3 + $val) % 128		\
		0xf7 }
}

#
# controllers config
#
proc mod    v { chanconfev [getc] {ctl [getc] 1  $v}; }
proc breath v { chanconfev [getc] {ctl [getc] 2  $v}; }
proc vol    v { chanconfev [getc] {ctl [getc] 7  $v}; }
proc bal    v { chanconfev [getc] {ctl [getc] 8  $v}; }
proc pan    v { chanconfev [getc] {ctl [getc] 10 $v}; }
proc reverb v { chanconfev [getc] {ctl [getc] 91 $v}; }
proc chorus v { chanconfev [getc] {ctl [getc] 93 $v}; }

#
# set RPN to the given value for the current chan
#
proc rpn addr val { 
	let c = [getc]
	chanconfev $c {rpn $c $addr $val}
}


#
# set NRPN to the given value for the current chan
#
proc nrpn addr val { 
	let c = [getc]
	chanconfev $c {nrpn $c $addr $val}
}
