Invocation:
-----------

	midish currently doesn't take any arguments, so it's started
	by typing:

		./midish

	in your shell. On startup, it tries to execute
	the script $HOME/.midishrc.

	You can specify your midi devices
	by using the function "devattach", for instance:

		devattach 0 "/dev/rmidi3"
		devattach 1 "/dev/rmidi1"

	will attach "/dev/rmidi3" and "/dev/rmidi1" as devices
	number 0 and 1. You can put those statements in 
	your $HOME/.midishrc

	once started, the sequencer reads and executes commands
	from stdin and writes results (and user non-fatal errors)
	to stdout. If stdin and stdout are both tty terminals, and if
	compiled with the readline(3) library an interactive prompt is
	used.

	fatal errors and other debugging information is logged
	to stderr.

	while performing real-time functions (playback,
	recording) the controlling terminal (see tty(1)) is
	polled. Real-time function is terminated if any key is
	pressed. Thus the sequencer must have controlling tty
	for real-time performance.

Lexical structure:
------------------

	the input line is split into tokens:

	- identifier:
		an identifier is a sequence of up to 32
		characters, digits and underscores ('_').
		However, an identifier cannot start with a
		digit. Examples:
			
		Good:
		 	mytrack, _mytrack, 
			my_track, my34track23 
		Bad:
			1mytrack, mytrackabcdefghijklmnopqrstuvwxyz


	- numbers
		numbers should be in decimal or hex format and may
		not exceed 2^31. Hex numbers are preceded
		by "0x", as in the C language. Examples:

			123	- 123 in decimal
			0x100	- 256 in hex
			0xF0	- 240 in hex
			
	- string constant:
		String constants are sequence of printable
		characters enclosed in pairs of double quotes.
		Thus a string cannot contain double quotes, 
		tabs, newlines.

	- keywords
		valid keywords are: 'nil', 'let', 'if', 'else',
		'for', and 'proc'.

	- operators, separators etc...
		sequences of meta-characters like '(', ')', '+',
		'$', newline character, ';',  etc... 

	- comments are ignored
		a comment begins with '#' and ends with the new line
		character.

	- multiple lines ending with '\' are parsed as a single line.

	- anything else generates a "bad token" error.

Syntax:
-------
	the input can be ether a function definition or a
	statement.

	
	Statements:

		Most of the statements end with the ';'
		character.  However, in order to improve
		interactivity, the newline character can be used
		instead. Thus, the newline character cannot be
		used as a space.

		A statement can be:

		- a procedure call, example:
	
			myproc arg1 arg2

		- an assignment using the 'let' keyword,
		  examples:

			let x = 123
			let y = 1 + 2 * (3 + x)

		  The left-hand side should be the name of
		  a variable and the right hand side an
		  expression (see the expression section).

					
		- an if..else statement, example:

			if $i {
				print "i is not zero";
			} else {
				print "i is zero";
			}

		  the 'else' and the second block are
		  not mandatory. Note that since newline
		  character is interpreted as a ';', the
		  line cannot be broken in an arbitrary
		  way. If the expression following the 'if'
		  keyword is true the first block is executed,
		  otherwise the second one (if any)is executed. The
		  expression is evaluated in the following way:

			  non-zero integer	true
			  zero integer		false
			  non-empty list	true
			  empty list		false
			  any name		true
			  nil			false
	
		- a loop over a list:

			for i in { "bli" "bla" "blu" } {
				print $i;
			}

		  the block is executed for each value
		  of the list to which '$i' is set.

		- a return statement. The return statement ends
		  the procedure execution and returns a
		  value to the caller. Example:

			return $x * $x;


	Constants:

		"this is a string"	- a string
		12345			- a decimal number			
		mytrack			- a name
		nil			- has no value

	Variables:
		values of a variable is obtained with the '$'
		character.

		let i = 123		# puts 123 in 'i'
		print $i		# prints the value of 'i'
		
	Expressions:

		an expression can be:

		- an arithmetic expression of constants,
		  expression, variable values, return values of
		  function calls. The following operators are 
		  recognised:
		
		 oper.	usage			associativity
		-----------------------------------------------
		  {}	list definition		left to right	
		  ()	grouping
		  []	function call
		-----------------------------------------------
		  !	logical NOT 		right to left
		  ~ 	bitwise NOT
		  - 	unary minus
		-----------------------------------------------
		  * 	multiplication		left to right
		  / 	division
		  %	reminder
		-----------------------------------------------
		  +	addition		left to right
		  -	subtraction
		-----------------------------------------------
		  << 	left shift		left to right
		  >>	right shift
		-----------------------------------------------
		  < 	less			left to right
		  <= 	less or equal
		  >	greater
		  >=	greater or equal
		-----------------------------------------------
		  == 	equal			left to right
		  != 	not equal
		-----------------------------------------------
		  &	bitwise AND		left to right
		-----------------------------------------------
		  ^	bitwise XOR		left to right
		-----------------------------------------------
		  |	bitwise OR		left to right
		-----------------------------------------------
		  &&	logical AND		left to right
		-----------------------------------------------
		  ||	logical OR		left to right
		-----------------------------------------------

		Examples:

			2 * (3 + 4) + $x

		is an usual integer arithmetic expression.


			[tracklen mytrack]
		
		is the returned value of the procedure 'tracklen'
		called with a single argument 'mytrack'.

			{ "bla" 3 zer }

		is a list containing the string "bla" the integer
		3 and the name 'zer'. A list is a set of
		expressions separated by spaces and enclosed by
		square brackets, a more complicated example is:

			{ "hello" 1+2*3 mytrack $i [myproc] { a b c } }	


	Procedure definition:

		a procedure is defined with the keyword
		'proc' followed by the name of the procedure, 
		the names of its arguments and a block containing
		its body, example:

			proc myprint x { 
				print $x
				return 2 * $x
			}

		the variables are local the the procedure
		and may shadow a global variable with the same
		name. The return value is given to the caller
		with a 'return' statement.

Events:
-------

	some functions take event arguments. An event
	is specified as list containing:
		- a reference from the followin list:
		  noff, non, kat, ctl, pc, cat, bend
		- a channel number
		- a number 
		- a second number (not for 'pc' and 'cat')
		
	Examples:
	
	{ non 0 64 100 }	- an note-on event on channel 0
				  note 64 with velocity 100
				  
				  
	{ ctl 9 7 99 }		- set value 99 to controller number 7
				  on channel 9
		
	{ pc 1 34 }		- select patch 34 on channel 1

Track functions:
----------------

	tracklist

		returns the list of names of the tracks in the song
		example:

			print [tracklist]

	tracknew trackname

		creates an empty track named 'trackname'

	trackexists trackname 

		returns 1 if 'trackname' is a track, 0 otherwise

	tracksetcurfilt trackname filtname

		sets the default filter (for recording) of
		'trackname' to 'filtname'
		
	trackgetcurfilt trackname

		returns the default filter (fpor recording) 
		of 'trackname', returns 'nil' if none
		
	trackcheck trackname

		checks the whole track for orphaned notes,
		nested notes and other anomalies; also
		removes multiple controllers in the same tic

	trackgetlen

		returns the size in tics of the current track,
		example:

			let l = [trackgetlen];

	tracksave trackname "filename"

		save the events of the track in a file

	trackload trackname "filename"

		loads the events of a track from a file

	trackcut trackname from amount quantum
	
		cuts 'amount' measures of the track 'trackname' 
		from measure 'from'.

	trackblank trackname from amount quantum

		clears 'amount' measures of the track 'trackname'
		from the measure 'from'.

	trackinsert trackname from amount

		inserts 'amount' blank measures in track
		'trackname' just before the measure 'from'

	trackcopy trackname1 from amount trackname2 where  quantum

		copies 'amount' measures starting at 'from' 
		from track 'trackname1' into 'trackname2'
		at position 'where'

	trackquant trackname from amount rate quantum
		
		quantises 'amount' measures of the track
		'trackname' from measure 'from' ; the quantum is
		the round in tics (see songsetsign). Rate must be
		between 0 and 100. 0 means no quantisation and
		100 means full quantisation.

	tracksetcurfilt trackname filtname

		set default filter to use for the next record
		of this track
		
	trackaddev trackname measure beat tic ev
	
		puts the event 'ev' on track 'trackname'
		at the positon given by 'measure',
		'beat' and 'tic'


Channel functions:
--------------------

	channew channelname channelnum

		creates an new channel named 'channelname'
		and bound to midi channel 'channelnum' 

	chanexists channelname

		returns 1 if 'channelname' is a channel, 0 otherwise

	changetnum channelname

		returns the midi channel number of channel named
		'channelname'
	
	chanconfev channelname event

		adds the event to the configuration of 
		channel 'channelname', typically used set
		the program, volume, depth etc... The channel
		of the event is not used.
		
	chaninfo channame
	
		prints all events on the config
		of the channel.

Filter functions:
--------------------

	filtnew filtname

		creates an new filter named 'filtname'

	filtexists filtname

		returns 1 if 'filtname' is a filter, 0 otherwise

	filtreset filtname

		removes all rules from the filter 'filtname'

	filtinfo filtname

		lists the rules of the given filter

	filtchangein filtname oldchan newchan

		changes the input channel of 
		all rules with input channel equal to 'oldchan'
		to 'newchan'

	filtchanmap filtname inputchan outputchan

		route all events from channel 'inputchan' 
		to channel 'outputchan'. If multiple channel maps are 
		defined for the same input channel then events are 
		duplicated

	filtkeymap filtname inputchan outputchan keystart keyend keyplus

		route note events from channel 'inputchan' and
		in the range keystart..keyend to outputchannel.
		Routed notes are transposed by keyplus half-tones
		If multiple keymaps are defined for the same input 
		channel and key-range then events are duplicated

	filtctlmap filtname inputchan outputchan inputctl outputctl

		route controller 'inputctl' from 'inputchan'
		to controller 'outputctl' on 'outputchan'.
		If multiple ctlmaps are defined for the same input 
		channel and the same input controller then events are duplicated


Real-time functions:
--------------------

	songrecord

		plays the song and records the input.
		Input passes through the filter of
		the current track (if any).

	songplay

		plays the song from the current position.
		Input passes through the filter of
		the current track (if any) or through
		the current filter (if any).

	songidle

		puts midi input to the midi output,
		data passes through the filter of
		the current track (if any) or through
		the current filter (if any).

	sendraw arrayofbytes

		sends raw midi data to the device,
		can be used to send system exclusive messages,
		example:

		sendraw { 0xF0 0x7E 0x7F 0x09 0x01 0xF7 }

Song functions:
---------------

	songsetcurquant tics

		set the number of tics in the time scale 
		(for quantisation, track editing...). 
		Currently this value is not used in real-time.

	songgetcurquant tics

		get the number of tics in the time scale.

	songsetcurpos measurenum

		set the current song position pointer to
		the measure 'measurenum'. record and playback
		will start a that position

	songgetcurpos

		returns the current measure ie the
		current song position pointer

	songsetcurtrack trackname

		set the current track ie the track to be recorded

	songgetcurtrack

		returns the current track (if any) or 'nil'


	songsetcurfilt filtname

		set the current filter ie the one used (with
		songplay and songidle) if there is no current track

	songgetcurfilt

		returns the current filter

	songsetunit tpu

		set the time resolution of the sequencer to 'tpu'
		tics per unit (1 unit = 4 quarter notes).  the
		unit shall be changed before creating any tracks. 
		The default is 96 tics per unit, which is the
		default of the midi standard.
		
	songgetunit
	
		returns the number of tics per unit note

	songsettempo measure bpm

		sets the tempo to 'bpm' beats per
		minute at measure 'measure'

	songtimeins from amount denominator numerator

		inserts 'amount' blank measures at measure
		'from'. The used time signature is given
		by denominator/numerator.

	songtimerm from amount

		deletes 'amount' measures starting at
		measure 'from'. The time signature is
		restored with the value preceding the
		'from' measure.
		
	songtimeinfo
	
		print the meta-track (tempo changes, time signature
		changes

	songinfo

		display some info about the default values of
		the song

	songsave filename

		saves the song in a file named 'filename'.

	songload filename

		load the song from a file named 'filename'.
		the current song is destroyed, even if 
		the load command failed

	songreset

		destroy completely the song, useful to
		start a new song without restarting the
		program

	songexportsmf filename

		saves the song into a standard midi file named 'filename'

	songimportsmf filename

		loads the song from a standard midi file named
		'filename'. Currently only midi file "type 1" is
		supported.

Device functions
----------------

	devlist
		returns the list of attached devices
		(list of numbers)

	devattach devnum filename

		attach midi device 'filename' as
		device number 'devnum'. 

	devdetach devnum

		detach device number 'devnum'
		

Misc. functions:
----------------

	metroswitch number

		if 'number' is equal to zero then the metronome is disabled
		else it is enabled
		
	metroconf eventhi eventlo
	
		select the notes that the metronome plays. The
		pair of events must be note-ons

	help
		display the list of built-in and user-defined
		procedures

	print expression

		displays the value of the expression

	exec "filename"

		reads and executes the script from "filename"
		
	debug flag val

		sets debug-flag 'flag' to (integer) value 'val'. 
		If val=0 the corresponding debug-info are
		turned off. 'flag' can be: 'parse', 'tree'		

	panic
	
		causes the sequencer to core-dump
	

