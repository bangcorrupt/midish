<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!--

Copyright (c) 2003-2005 Alexandre Ratchov
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions 
are met:

	- Redistributions of source code must retain the above
	  copyright notice, this list of conditions and the 
	  following disclaimer.

	- Redistributions in binary form must reproduce the above
	  copyright notice, this list of conditions and the 
	  following disclaimer in the documentation and/or other 
	  materials  provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 

-->

<HTML>
<HEAD>
<TITLE>midish version 0.2 - user's manual</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</HEAD>
<BODY bgcolor="white" text="black" link="blue" vlink="navy">

<H1>Table of contents</H1>
<P>
<UL>
<LI><A href="#intro">Introduction</A>
<LI><A href="#install">Installation</A>
<LI><A href="#changes">Changes</A>
<LI><A href="#language">Language reference</A>
<LI><A href="#devices">Devices and channels</A>
<LI><A href="#events">Events</A>
<LI><A href="#filters">Filters</A>
<LI><A href="#tracks">Tracks</A>
<LI><A href="#functions">Function reference</A>
</UL>


<A name="intro"></A>
<H1>Introduction</H1>

	<P>
	Midish is a MIDI sequencing and filtering tool for 
	unix-like operating systems.
 
	It's is implemented as a sequencing engine and a 
	command-line interpreter.

<A name="install"></A>
<H1>Installation</H1>

<H2>Requirements</H2>

	Requirements:
	<UL>
	<LI>	a midi sound module 
	<LI>	a midi keyboard
	<LI>	an unix-like operating system with "raw" midi support.
		Midish works on OpenBSD (its development platform)
		and Linux.
	</UL>

<H2>Installation</H2>

	<UL>
	<LI> untar and gunzip the tar-ball:

	<PRE>
	gzip -dc midish-0.1.tar.gz | tar xf -
	cd midish-0.1
	</PRE>

	<LI> 
	edit <TT>Makefile</TT> and change <TT>CC</TT>, 
	<TT>CFLAGS</TT>, etc... (if needed)

	<LI> 
	comment or uncomment readline(3) options in Makefile

	<LI> 
	compile the sequencer, just type '<TT>make all</TT>'

	<LI>
	install binaries by typing '<TT>make install</TT>'; by default
	they are installed in <TT>$HOME/bin</TT>, where <TT>$HOME</TT> is
	your home directory. If you want to change this,
	set the <TT>PREFIX</TT> variable, for instance: 

	<PRE>
	make PREFIX=/usr/local install
	</PRE>

	<LI>
	if you don't have a .midishrc, copy the sample file by
	typing '<TT>cp midishrc ~/.midishrc</TT>' in your shell

	<LI>
	read the documentation and edit your <TT>~/.midishrc</TT> in order 
	to choose your default midi device by using the <TT>devattach</TT> 
	function (example: '<TT>devattach 0 "/dev/rmidi3"</TT>', see next section)

	</UL>

<H2>Invocation</H2>
	<P>
	when used interactively, midish doesn't need any arguments, 
	so it's started	by typing:

	<PRE>
	./midish
	</PRE>

	in your shell. On startup, it tries to execute
	the script <TT>$HOME/.midishrc</TT>. If you
	don't want so, use the <TT>-norc</TT> flag. This is
	useful when you want to use midish in scripts.

	You can specify your midi devices
	by using the function <TT>devattach</TT>, for instance:

	<PRE>
	devattach 0 "/dev/rmidi3"
	devattach 1 "/dev/rmidi1"
	</PRE>

	will attach <TT>/dev/rmidi3</TT> and <TT>/dev/rmidi1</TT> as devices
	number 0 and 1. You can put those statements in 
	your <TT>$HOME/.midishrc</TT>

	<P>
	Once started, the sequencer reads and executes commands
	from stdin and writes results (and user non-fatal errors)
	to stdout. If stdin and stdout are both tty terminals, and if
	compiled with the readline(3) library an interactive prompt is
	used.

	Fatal errors and other debugging information is logged
	to stderr.

	While performing real-time functions (playback,
	recording) the controlling terminal (see tty(1)) is
	polled. Real-time function is terminated if any key is
	pressed. Thus the sequencer must have controlling tty
	for real-time performance.

	<P>
	You can try to play the demo song in the source tar-ball

	<PRE>
	songload "sample.sng"
	songplay
	</PRE>


<A name="changes"></A>
<H1>Changes</H1>
<H2>from release 0.1 to release 0.2</H2>

	<UL>
	<LI> added <TT>device</TT>-parameter to <TT>sendraw</TT>
	<LI> replaced <TT>filtchangein</TT> to <TT>filtswapichan</TT>
		and added the "device" corresponding <TT>filtswapidev</TT>
	<LI> added new filter rules: 
		<TT>filtdevdrop</TT>, 
		<TT>filtchandrop</TT>,
		<TT>filtctldrop</TT> and 
		<TT>filtkeydrop</TT>.
	<LI> added functions that remove existing rules: 
		<TT>filtnodevdrop</TT>, 
		<TT>filtnodevmap</TT>, 
		<TT>filtnochandrop</TT>,
		<TT>filtnochanmap</TT>,
		<TT>filtnoctldrop</TT>,
		<TT>filtnoctlmap</TT>,
		<TT>filtnokeydrop</TT> and
		<TT>filtnokeymap</TT>.
	<LI> added support for external midi synchronisation,
	     added <TT>devsetmaster</TT>, <TT>devgetmaster</TT>
	     and <TT>devsendrt</TT>
	<LI> added 
		<TT>trackdelete</TT>,
		<TT>chandelete</TT>, 
		<TT>filtdelete</TT>
	<LI> added 
		<TT>trackrename</TT>,
		<TT>chanrename</TT>, 
		<TT>filtrename</TT>
	</UL>

<A name="language"></A>
<H1>Language reference</H1>
<H2>Lexical structure</H2>

	The input line is split into tokens:

	<UL>
	<LI> Identifiers:
		<BR>
		an identifier is a sequence of up to 32
		characters, digits and underscores (<TT>_</TT>).
		However, an identifier cannot start with a
		digit. Examples:
	<PRE>
	mytrack _mytrack  my34_track23		# good
	123mytrack 				# bad, starts with digit
	mytrackabcdefghijklmnopqrstuvwxyz	# bad, to long
	</PRE>
	
	<LI> Numbers 
		<BR>
		numbers should be in decimal or hex format and may
		not exceed 2^31. Hex numbers are preceded
		by "0x", as in the C language. Examples:
		
		<P align="center">
		<TABLE border="1">
		<TR>	<TD><TT>123</TT>	<TD>123 in decimal
		<TR>	<TD><TT>0x100</TT>	<TD>256 in hex
		<TR>	<TD><TT>0xF0</TT>	<TD>240 in hex
		</TABLE>
			
	<LI> String constants
		<BR>
		string constants are sequence of printable
		characters enclosed in pairs of double quotes.
		Thus a string cannot contain double quotes, 
		tabs, newlines.

	<LI> Keywords
		<BR>
		valid keywords are: <TT>nil</TT>, <TT>let</TT>, 
		<TT>if</TT>, <TT>else</TT>, <TT>for</TT>, and <TT>proc</TT>.

	<LI> Operators, separators etc...
		<BR>
		sequences of meta-characters like '<TT>(</TT>', '<TT>)</TT>', 
		'<TT>+</TT>', '<TT>$</TT>', newline character, 
		'<TT>;</TT>',  etc... 

	<LI> Comments 
		<BR>
		comments are ignored, they start with '<TT>#</TT>' 
		and end with the new line
		character.

	</UL>

	Multiple lines ending with '<TT>\</TT>' are parsed as a 
	single line. Anything else generates a "bad token" error.


<H2>Statements</H2>

	<P>
	The input can be ether a function definition or a
	statement. 

	Most of the statements end with the '<TT>;</TT>'
	character.  However, in order to improve
	interactivity, the newline character can be used
	instead. Thus, the newline character cannot be
	used as a space.

	A statement can be:
		
	<UL>
	<LI>
	A procedure call, example:

	<PRE>
	myproc arg1 arg2
	</PRE>


	<LI>
	An assignment using the <TT>let</TT> keyword,
	examples:

	<PRE>
	let x = 123
	let y = 1 + 2 * (3 + x)
	</PRE>

	<P>
	The left-hand side should be the name of
	a variable and the right hand side an
	expression (see the expression section).


	<LI>
	An <TT>if..else</TT> statement, example:

	<PRE>
	if $i {
		print "i is not zero";
	} else {
		print "i is zero";
	}
	</PRE>

	the <TT>else</TT> and the second block are
	not mandatory. Note that since newline
	character is interpreted as a '<TT>;</TT>', the
	line cannot be broken in an arbitrary
	way. If the expression following the <TT>if</TT>
	keyword is true the first block is executed,
	otherwise the second one (if any) is executed. The
	expression is evaluated in the following way:

	<P align="center">
	<TABLE border="1">
	<TR>	<TD>non-zero integer	<TD>true
	<TR>	<TD>zero integer	<TD>false
	<TR>	<TD>non-empty list	<TD>true
	<TR>	<TD>empty list		<TD>false
	<TR>	<TD>any name		<TD>true
	<TR>	<TD>nil			<td>false
	</TABLE>
	
	<LI>
	A loop over a list:

	<PRE>
	for i in { "bli" "bla" "blu" } {
		print $i;
	}
	</PRE>

	the block is executed for each value
	of the list to which '<TT>$i</TT>' is set.

	<LI>
	A return statement. The return statement ends
	the procedure execution and returns a
	value to the caller. Example:

	<PRE>
	return $x * $x;
	</PRE>

	</UL>


<H2>Expressions</H2>

	An expression can be an arithmetic expression of constants,
	expressions, variable values, return values of
	function calls. 

	The following constant types are supported:

	<P align="center">
	<TABLE border="1">
	<TR>	<TD><TT>"this is a string"</TT>		<TD> a string
	<TR>	<TD><TT>12345</TT>			<TD> a number
	<TR>	<TD><TT>mytrack</TT>			<TD> a reference
	<TR>	<TD><TT>nil</TT>			<TD> has no value
	</TABLE>

	<P>
	Variable are referenced by their identifier. 
	Value of a variable is obtained with the '<TT>$</TT>'
	character.

	<PRE>
	let i = 123		# puts 123 in 'i'
	print $i		# prints the value of 'i'
	</PRE>

	The following operators are recognised:

	<P align="center">
	<TABLE border="1">

	<TR>	<TH>oper.	<TH>usage		<TH>associativity

	<TR>	<TD><TT>{}</TT>	
		<TD>list definition	
		<TD rowspan="3">left to right

	<TR>	<TD><TT>()</TT>	
		<TD>grouping		

	<TR>	<TD><TT>[]</TT>	
		<TD>function call

	<TR>	<TD><TT>!</TT>	
		<TD>logical NOT 	
		<TD rowspan="3">right to left

	<TR>	<TD><TT>~</TT>	
		<TD>bitwise NOT		

	<TR>	<TD><TT>-</TT>
		<TD>unary minus

	<TR>	<TD><TT>*</TT>
	 	<TD>multiplication
		<TD rowspan="3">left to right

	<TR>	<TD><TT>/</TT>
		<TD>division

	<TR>	<TD><TT>%</TT
		<TD>reminder

	<TR>	<TD><TT>+</TT
		<TD>addition
		<TD rowspan="2">left to right

	<TR>	<TD><TT>-</TT
		<TD>subtraction

	<TR>	<TD><TT>&lt;&lt;</TT
		<TD>left shift	
		<TD rowspan="2">left to right

	<TR>	<TD><TT>&gt;&gt;</TT
		<TD>right shift
	
	<TR>	<TD><TT>&lt;</TT>
		<TD>less
		<TD rowspan="4">left to right

	<TR>	<TD><TT>&lt;=</TT>
		<TD>less or equal

	<TR>	<TD><TT>&gt;</TT>
		<TD>greater

	<TR>	<TD><TT>&gt;=</TT>
		<TD>greater or equa

	<TR>	<TD><TT>==</TT>
		<TD>equal
		<TD rowspan="2">left to righ

	<TR>	<TD><TT>!=</TT>
		<TD>not equa

	<TR>	<TD><TT>&amp;</TT>
		<TD>bitwise AND
		<TD>left to right

	<TR>	<TD><TT>^</TT>
		<TD>bitwise XOR
		<TD>left to right

	<TR>	<TD><TT>|</TT>
		<TD>bitwise OR
		<TD>left to right

	<TR>	<TD><TT>&amp;&amp;</TT>
		<TD>logical AND
		<TD>left to right

	<TR>	<TD><TT>||</TT>
		<TD>logical OR
		<TD>left to right
	</TABLE>

	<P>
	Examples:

	<PRE>	
	2 * (3 + 4) + $x
	</PRE>

	is an usual integer arithmetic expression.

	<PRE>
	[tracklen mytrack]
	</PRE>
		
	is the returned value of the procedure <TT>tracklen</TT>
	called with a single argument <TT>mytrack</TT>.

	<PRE>
	{ "bla" 3 zer }
	</PRE>

	is a list containing the string <TT>"bla"</TT> the integer
	3 and the name <TT>zer</TT>. A list is a set of
	expressions separated by spaces and enclosed by
	square brackets, a more complicated example is:

	<PRE>
	{ "hello" 1+2*3 mytrack $i [myproc] { a b c } }	
	</PRE>


<H2>Procedure definition</H2>

	A procedure is defined with the keyword
	<TT>proc</TT> followed by the name of the procedure, 
	the names of its arguments and a block containing
	its body, example:

	<PRE>
	proc doubleprint x y { 
		print $x
		print $y
	}
	</PRE>

	Argulements and variables defined whithin a procedure 
	are local to that procedure
	and may shadow a global variable with the same
	name. The return value is given to the caller
	with a <TT>return</TT> statement:

	<PRE>
	proc square x {
		return $x * $y
	}
	</PRE>

<A name="devices"></A>
<H1>Devices and channels</H1>

	<P>
	Devices are numbered between 0 and 15. They are
	configured with <TT>devattach</TT> and <TT>devdetach</TT>.
	Example:

	<PRE>
	devattach 0 "/dev/rmidi3"
	</PRE>

	Channels are specified by giving the device number
	and the midi channel number in a list:

	<PRE>
	{ devicenum midichan }
	</PRE>

	For instance, to specify channel 9 on device number 2:

	<PRE>
	{ 2 9 }
	</PRE>
	
	<P>
	Named channels can be specified by their names, for
	instance, after:

	<PRE>
	channew drums { 2 9 }	# define a named channel
	</PRE>
		
	<TT>drums</TT> and <TT>{2 9}</TT> become equivalent. Named channels
	can be also used to hold some configuration events,
	see <TT>channew</TT>, <TT>chanconfev</TT>

<A name="events"></A>
<H1>Events</H1>

	<P>
	Some functions take events as arguments. An event
	is specified as a list containing:
	<UL>
	<LI> a reference from the following list:
	     <TT>noff</TT>, <TT>non</TT>, <TT>kat</TT>, 
	     <TT>ctl</TT>, <TT>pc</TT>, <TT>cat</TT>, <TT>bend</TT>.
	<LI> a channel
	<LI> a number 
	<LI> a second number (not for <TT>pc</TT> and <TT>cat</TT>)
	</UL>
		
	Event references correspond to the following
	midi events:
	<P align="center">
	<TABLE border="1">
	<TR>	<TD><TT>noff</TT>	<TD>note off
	<TR>	<TD><TT>non</TT>	<TD>note off
	<TR>	<TD><TT>kat</TT>	<TD>key after-touch (poly)
	<TR>	<TD><TT>ctl</TT>	<TD>controller
	<TR>	<TD><TT>pc</TT>		<TD>program change
	<TR>	<TD><TT>cat</TT>	<TD>channel after-touch (mono)
	<TR>	<TD><TT>bend</TT>	<TD>pitch bend
	</TABLE>

	<P>
	Examples:
	<BR>
	note-on event on device 2, channel 9, note 64 with velocity 100:

	<PRE>
	{ non {2 9} 64 100 }
	</PRE>

	program change device 1, channel 3, patch 34

	<PRE>
	{ pc {1 3} 34 }
	</PRE>

	set controller number 7 to 99
	on device/channel drums:

	<PRE>
	{ ctl drums 7 99 }
	</PRE>


<A name="filters"></A>
<H1>Filters</H1>

	<P>
	Filters are used to route midi events between channels and 
	devices, to make keyboard splits and controller mappings. 
	For instance to route events on device 0 channel 0 to
	device 1 channel 9:

	<PRE>
	filtnew myfilt
	filtchanmap {0 0} {1 9}
	</PRE>

	to map controller 7 (volume) on channel 0, device 0 to controller
	11 (expression) on channel 9, device 1:

	<PRE>
	filtctlmap {0 0} {1 9} 7 11
	</PRE>

<A name="tracks"></A>
<H1>Tracks</H1>

	<P>
	A track is a set of events ordered in time. They can be
	recorded, edited and quantised. Each track has a name and
	and a default filter (used for recording). Tracks are
	not bound to a specific channel/device and can
	be used to record a complete song (not recommended).
	On playback all tracks are played simultaneously.

<A name="functs"></A>
<H1>Function reference</H1>

<H2>Track functions</H2>

<B><TT>tracklist</TT></B>
	<BLOCKQUOTE>
	returns the list of names of the tracks in the song
	example:
	<PRE>
	print [tracklist]
	</PRE>
	</BLOCKQUOTE>

<B><TT>tracknew trackname</TT></B>
	<BLOCKQUOTE>
	creates an empty track named <TT>trackname</TT>
	</BLOCKQUOTE>

<B><TT>trackdelete trackname</TT></B>
	<BLOCKQUOTE>
	delete existing track '<TT>trackname</TT>'.
	Current track cannot be deleted.
	</BLOCKQUOTE>

<B><TT>trackrename trackname newname</TT></B>
	<BLOCKQUOTE>
	rename track '<TT>trackname</TT>' to '<TT>newname</TT>'
	</BLOCKQUOTE>

<B><TT>trackexists trackname</TT></B>
	<BLOCKQUOTE>
	returns 1 if <TT>trackname</TT> is a track, 0 otherwise
	</BLOCKQUOTE>

<B><TT>tracksetcurfilt trackname filtname</TT></B>
	<BLOCKQUOTE>
	sets the default filter (for recording) of
	<TT>trackname</TT> to <TT>filtname</TT>
	</BLOCKQUOTE>

<B><TT>trackgetcurfilt trackname</TT></B>
	<BLOCKQUOTE>
	returns the default filter (for recording) 
	of <TT>trackname</TT>, returns <TT>nil</TT> if none
	</BLOCKQUOTE>
		
<B><TT>trackcheck trackname</TT></B>
	<BLOCKQUOTE>
	checks the whole track for orphaned notes,
	nested notes and other anomalies; also
	removes multiple controllers in the same tic
	</BLOCKQUOTE>

<B><TT>trackgetlen</TT></B>
	<BLOCKQUOTE>
	returns the size in tics of the current track,
	example:
	<PRE>
	let l = [trackgetlen];
	</PRE>
	</BLOCKQUOTE>

<B><TT>tracksave trackname filename</TT></B>
	<BLOCKQUOTE>
	save the events of the track in a file, <TT>filename</TT>
	is a quoted string.
	</BLOCKQUOTE>

<B><TT>trackload trackname filename</TT></B>
	<BLOCKQUOTE>
	loads the events of a track from a file, <TT>filename</TT>
	is a quoted string.
	</BLOCKQUOTE>

<B><TT>trackcut trackname from amount quantum</TT></B>
	<BLOCKQUOTE>
	cuts <TT>amount</TT> measures of the track <TT>trackname</TT>
	from measure <TT>from</TT>.
	</BLOCKQUOTE>

<B><TT>trackblank trackname from amount quantum</TT></B>
	<BLOCKQUOTE>
	clears <TT>amount</TT> measures of the track <TT>trackname</TT>
	from the measure <TT>from</TT>.
	</BLOCKQUOTE>

<B><TT>trackinsert trackname from amount</TT></B>
	<BLOCKQUOTE>
	inserts <TT>amount</TT> blank measures in track
	<TT>trackname</TT> just before the measure <TT>from</TT>
	</BLOCKQUOTE>

<B><TT>trackcopy trackname1 from amount trackname2 where  quantum</TT></B>
	<BLOCKQUOTE>
	copies <TT>amount</TT> measures starting at <TT>from</TT>
	from track <TT>trackname1</TT> into <TT>trackname2</TT>
	at position <TT>where</TT>
	</BLOCKQUOTE>

<B><TT>trackquant trackname from amount rate quantum</TT></B>
	<BLOCKQUOTE>
	quantises <TT>amount</TT> measures of the track
	<TT>trackname</TT> from measure <TT>from</TT> ; the quantum is
	the round in tics (see songsetsign). Rate must be
	between 0 and 100. 0 means no quantisation and
	100 means full quantisation.
	</BLOCKQUOTE>

<B><TT>tracksetcurfilt trackname filtname</TT></B>
	<BLOCKQUOTE>
	set default filter to use for the next record
	of this track
	</BLOCKQUOTE>

<B><TT>trackaddev trackname measure beat tic ev</TT></B>
	<BLOCKQUOTE>
	puts the event <TT>ev</TT> on track <TT>trackname</TT>
	at the position given by <TT>measure</TT>,
	<TT>beat</TT> and <TT>tic</TT>
	</BLOCKQUOTE>

<H2>Channel functions</H2>

<B><TT>channew channelname channelnum</TT></B>
	<BLOCKQUOTE>
	creates an new channel named <TT>channelname</TT>
	and bound to midi channel <TT>channelnum</TT> 
	</BLOCKQUOTE>

<B><TT>chandelete channame</TT></B>
	<BLOCKQUOTE>
	delete existing channel '<TT>channame</TT>'.
	</BLOCKQUOTE>

<B><TT>chanrename channame newname</TT></B>
	<BLOCKQUOTE>
	rename channel '<TT>channame</TT>' to '<TT>newname</TT>'
	</BLOCKQUOTE>

<B><TT>chanexists channelname</TT></B>
	<BLOCKQUOTE>
	returns 1 if <TT>channelname</TT> is a channel, 0 otherwise
	</BLOCKQUOTE>

<B><TT>changetnum channelname</TT></B>
	<BLOCKQUOTE>
	returns the midi channel number of channel named
	<TT>channelname</TT>
	</BLOCKQUOTE>

<B><TT>changetdev channelname</TT></B>
	<BLOCKQUOTE>
	returns the device number of channel named
	<TT>channelname</TT>
	</BLOCKQUOTE>

<B><TT>chanconfev channelname event</TT></B>
	<BLOCKQUOTE>
	adds the event to the configuration of 
	channel <TT>channelname</TT>, typically used set
	the program, volume, depth etc... The channel
	of the event is not used.
	</BLOCKQUOTE>

<B><TT>chaninfo channame</TT></B>
	<BLOCKQUOTE>
	prints all events on the config
	of the channel.
	</BLOCKQUOTE>


<H2>Filter functions</H2>

<B><TT>filtnew filtname</TT></B>
	<BLOCKQUOTE>
	creates an new filter named <TT>filtname</TT>
	</BLOCKQUOTE>

<B><TT>filtdelete filtname</TT></B>
	<BLOCKQUOTE>
	delete existing filter '<TT>filtname</TT>'.
	Current filter and filters used by tracks cannot be deleted.
	</BLOCKQUOTE>

<B><TT>filtrename filtname newname</TT></B>
	<BLOCKQUOTE>
	rename filter '<TT>filtname</TT>' to '<TT>newname</TT>'
	</BLOCKQUOTE>

<B><TT>filtexists filtname</TT></B>
	<BLOCKQUOTE>
	returns 1 if <TT>filtname</TT> is a filter, 0 otherwise
	</BLOCKQUOTE>

<B><TT>filtreset filtname</TT></B>
	<BLOCKQUOTE>
	removes all rules from the filter <TT>filtname</TT>
	</BLOCKQUOTE>

<B><TT>filtinfo filtname</TT></B>
	<BLOCKQUOTE>
	lists the rules of the given filter
	</BLOCKQUOTE>

<B><TT>filtswapichan filtname oldchan newchan</TT></B>
	<BLOCKQUOTE>
	changes the input channel of 
	all rules with input channel equal to <TT>oldchan</TT>
	to <TT>newchan</TT>, and the input channel of 
	all rules with input channel equal to <TT>newchan</TT>
	to <TT>oldchan</TT>,
	</BLOCKQUOTE>

<B><TT>filtswapidev filtname olddev newdev</TT></B>
	<BLOCKQUOTE>
	changes the input device of 
	all rules with input device equal to <TT>olddev</TT>
	to <TT>newdev</TT>, and the input device of 
	all rules with input device equal to <TT>newdev</TT>
	to <TT>olddev</TT>
	</BLOCKQUOTE>

<B><TT>filtdevdrop filtname inputdev</TT></B>
	<BLOCKQUOTE>
	make filter drop events from device <TT>inputdev</TT>
	</BLOCKQUOTE>

<B><TT>filtnodevdrop filtname inputdev</TT></B>
	<BLOCKQUOTE>
	remove <TT>devdrop</TT> rules that drop events from device <TT>inputdev</TT>
	</BLOCKQUOTE>

<B><TT>filtdevmap filtname inputdev outputdev</TT></B>
	<BLOCKQUOTE>
	route all events from device <TT>inputdev</TT>
	to device <TT>outputdev</TT>. If multiple dev maps are 
	defined for the same input device then events are 
	duplicated
	</BLOCKQUOTE>

<B><TT>filtnodevmap filtname outputdev</TT></B>
	<BLOCKQUOTE>
	remove <TT>devmap</TT> rules that route events to 
	device number <TT>outputdev</TT>. 
	</BLOCKQUOTE>


<B><TT>filtchandrop filtname inputchan</TT></B>
	<BLOCKQUOTE>
	make filter drop events from channel <TT>inputchan</TT>
	</BLOCKQUOTE>

<B><TT>filtchandrop filtname inputchan</TT></B>
	<BLOCKQUOTE>
	remove <TT>chandrop</TT> rules that 
	drop events from channel <TT>inputchan</TT>
	</BLOCKQUOTE>

<B><TT>filtchanmap filtname outputchan</TT></B>
	<BLOCKQUOTE>
	remove channel map rules that route events to channel 
	<TT>outputchan</TT>. 
	</BLOCKQUOTE>

<B><TT>filtctldrop filtname inchan inctl</TT></B>
	<BLOCKQUOTE>
	make the filter drop controller number <TT>inctl</TT> 
	on channel <TT>inctl</TT>.
	</BLOCKQUOTE>

<B><TT>filtnoctldrop filtname inchan inctl</TT></B>
	<BLOCKQUOTE>
	remove <TT>ctldrop</TT> rules that drop controller number 
	<TT>inctl</TT> 	on channel <TT>inctl</TT>.
	</BLOCKQUOTE>

<B><TT>filtctlmap filtname inchan outchan inctl outctl</TT></B>
	<BLOCKQUOTE>
	route controller <TT>inctl</TT> from <TT>inchan</TT>
	to controller <TT>outctl</TT> on <TT>outchan</TT>.
	If multiple ctlmaps are defined for the same input 
	channel and the same input controller then events are duplicated
	</BLOCKQUOTE>

<B><TT>filtnoctlmap filtname outchan outctl</TT></B>
	<BLOCKQUOTE>
	remove <TT>ctlmap</TT> rules that route controllers to
	controller <TT>outctl</TT>, channel <TT>outchan</TT>.
	</BLOCKQUOTE>

<B><TT>filtkeydrop filtname inchan keystart keyend</TT></B>
	<BLOCKQUOTE>
	drop notes between <TT>keystart</TT> and <TT>keyend</TT>
	on channel <TT>inchan</TT>.
	</BLOCKQUOTE>

<B><TT>filtnokeydrop filtname inchan keystart keyend</TT></B>
	<BLOCKQUOTE>
	remove <TT>keydrop</TT> rule that drop notes between 
	<TT>keystart</TT> and <TT>keyend</TT>
	on channel <TT>inchan</TT>.
	</BLOCKQUOTE>


<B><TT>filtkeymap filtname inchan outchan keystart keyend keyplus</TT></B>
	<BLOCKQUOTE>
	route note events from channel <TT>inchan</TT> and
	in the range <TT>keystart..keyend</TT> to <TT>outchan</TT>.
	Routed notes are transposed by keyplus half-tones
	If multiple keymaps are defined for the same input 
	channel and key-range then events are duplicated
	</BLOCKQUOTE>


<B><TT>filtnokeymap filtname outchan keystart keyend</TT></B>
	<BLOCKQUOTE>
	remove <TT>keymap</TT> rules that route note events 
	in the range <TT>keystart..keyend</TT> to channel <TT>outchan</TT>.
	</BLOCKQUOTE>


<H2>Real-time functions</H2>

<B><TT>songrecord</TT></B>
	<BLOCKQUOTE>
	plays the song and records the input.
	Input passes through the filter of
	the current track (if any).
	</BLOCKQUOTE>

<B><TT>songplay</TT></B>
	<BLOCKQUOTE>
	plays the song from the current position.
	Input passes through the filter of
	the current track (if any) or through
	the current filter (if any).
	</BLOCKQUOTE>

<B><TT>songidle</TT></B>
	<BLOCKQUOTE>
	puts midi input to the midi output,
	data passes through the filter of
	the current track (if any) or through
	the current filter (if any).
	</BLOCKQUOTE>

<B><TT>sendraw device arrayofbytes</TT></B>
	<BLOCKQUOTE>
	sends raw midi data to device number '<TT>device</TT>',
	can be used to send system exclusive messages,
	example:
	<PRE>
	sendraw 0 { 0xF0 0x7E 0x7F 0x09 0x01 0xF7 }
	</PRE>
	</BLOCKQUOTE>

<H2>Song functions</H2>

<B><TT>songsetcurquant tics</TT></B>
	<BLOCKQUOTE>
	set the number of tics in the time scale 
	(for quantisation, track editing...). 
	Currently this value is not used in real-time.
	</BLOCKQUOTE>

<B><TT>songgetcurquant tics</TT></B>
	<BLOCKQUOTE>
	get the number of tics in the time scale.
	</BLOCKQUOTE>

<B><TT>songsetcurpos measure</TT></B>
	<BLOCKQUOTE>
	set the current song position pointer to
	the measure <TT>measure</TT>. record and playback
	will start a that position
	</BLOCKQUOTE>

<B><TT>songgetcurpos</TT></B>
	<BLOCKQUOTE>
	returns the current measure ie the
	current song position pointer
	</BLOCKQUOTE>

<B><TT>songsetcurtrack trackname</TT></B>
	<BLOCKQUOTE>
	set the current track ie the track to be recorded
	</BLOCKQUOTE>

<B><TT>songgetcurtrack</TT></B>
	<BLOCKQUOTE>
	returns the current track (if any) or <TT>nil</TT>
	</BLOCKQUOTE>

<B><TT>songsetcurfilt filtname</TT></B>
	<BLOCKQUOTE>
	set the current filter ie the one used (with
	songplay and songidle) if there is no current track
	</BLOCKQUOTE>

<B><TT>songgetcurfilt</TT></B>
	<BLOCKQUOTE>
	returns the current filter
	</BLOCKQUOTE>

<B><TT>songsetunit tpu</TT></B>
	<BLOCKQUOTE>
	set the time resolution of the sequencer to <TT>tpu</TT>
	tics per unit (1 unit = 4 quarter notes).  the
	unit shall be changed before creating any tracks. 
	The default is 96 tics per unit, which is the
	default of the midi standard.
	</BLOCKQUOTE>

<B><TT>songgetunit</TT></B>
	<BLOCKQUOTE>
	returns the number of tics per unit note
	</BLOCKQUOTE>

<B><TT>songsettempo measure bpm</TT></B>
	<BLOCKQUOTE>
	sets the tempo to <TT>bpm</TT> beats per
	minute at measure <TT>measure</TT>
	</BLOCKQUOTE>

<B><TT>songtimeins from amount denominator numerator</TT></B>
	<BLOCKQUOTE>
	inserts <TT>amount</TT> blank measures at measure
	<TT>from</TT>. The used time signature is given
	by denominator/numerator.
	</BLOCKQUOTE>

<B><TT>songtimerm from amount</TT></B>
	<BLOCKQUOTE>
	deletes <TT>amount</TT> measures starting at
	measure <TT>from</TT>. The time signature is
	restored with the value preceding the
	<TT>from</TT> measure.
	</BLOCKQUOTE>

<B><TT>songtimeinfo</TT></B>
	<BLOCKQUOTE>
	print the meta-track (tempo changes, time signature
	changes
	</BLOCKQUOTE>

<B><TT>songinfo</TT></B>
	<BLOCKQUOTE>
	display some info about the default values of
	the song
	</BLOCKQUOTE>

<B><TT>songsave filename</TT></B>
	<BLOCKQUOTE>
	saves the song in a file, <TT>filename</TT>
	is a quoted string.
	</BLOCKQUOTE>

<B><TT>songload filename</TT></B>
	<BLOCKQUOTE>
	load the song from a file named <TT>filename</TT>.
	the current song is destroyed, even if 
	the load command failed
	</BLOCKQUOTE>

<B><TT>songreset</TT></B>
	<BLOCKQUOTE>
	destroy completely the song, useful to
	start a new song without restarting the
	program
	</BLOCKQUOTE>

<B><TT>songexportsmf filename</TT></B>
	<BLOCKQUOTE>
	saves the song into a standard midi file, <TT>filename</TT>
	is a quoted string.
	</BLOCKQUOTE>

<B><TT>songimportsmf filename</TT></B>
	<BLOCKQUOTE>
	loads the song from a standard midi file, <TT>filename</TT>
	is a quoted string. Currently only midi file "type 1" is
	supported.
	</BLOCKQUOTE>

<H2>Device functions</H2>

<B><TT>devlist</TT></B>
	<BLOCKQUOTE>
	returns the list of attached devices
	(list of numbers)
	</BLOCKQUOTE>

<B><TT>devattach devnum filename</TT></B>
	<BLOCKQUOTE>
	attach midi device <TT>filename</TT> as
	device number <TT>devnum</TT>; <TT>filename</TT>
	is a quoted string.
	</BLOCKQUOTE>

<B><TT>devdetach devnum</TT></B>
	<BLOCKQUOTE>
	detach device number <TT>devnum</TT>
	</BLOCKQUOTE>

<B><TT>devsetmaster devnum</TT></B>
	<BLOCKQUOTE>
	set device number <TT>devnum</TT> to be the master clock source.
	It will give tempo, start event and stop event. If <TT>devnum</TT> is
	<TT>nil</TT>, then the internal clock will be used and midish
	will act as master device.
	</BLOCKQUOTE>

<B><TT>devgetmaster devnum</TT></B>
	<BLOCKQUOTE>
	return the current master device. If non, <TT>nil</TT> is
	returned.
	</BLOCKQUOTE>

<B><TT>devsendrt devnum bool</TT></B>
	<BLOCKQUOTE>
	If <TT>bool</TT> is true, the real-time information (midi tics, 
	midi start and midi trop events) will be transmitted to device
	number <TT>devnum</TT>. 
	Overwise no real-time midi events are transmitted.
	</BLOCKQUOTE>
		
<B><TT>devticrate devnum ticrate</TT></B>
	<BLOCKQUOTE>
	set the number of tics per unit note that are transmitted
	to the midi device if "sendrt" feature is active. Defaut
	value is 96 tics. This is the standard MIDI value and
	its not recommended to change it.
	</BLOCKQUOTE>
	
<B><TT>devinfo devnum</TT></B>
	<BLOCKQUOTE>
	Print some information about the midi device.
	</BLOCKQUOTE>

<H2>Misc. functions</H2>

<B><TT>metroswitch number</TT></B>
	<BLOCKQUOTE>
	if <TT>number</TT> is equal to zero then the metronome is disabled
	else it is enabled
	</BLOCKQUOTE>	

<B><TT>metroconf eventhi eventlo</TT></B>
	<BLOCKQUOTE>	
	select the notes that the metronome plays. The
	pair of events must be note-ons
	</BLOCKQUOTE>
	
<B><TT>help</TT></B>
	<BLOCKQUOTE>
	display the list of built-in and user-defined
	procedures
	</BLOCKQUOTE>

<B><TT>print expression</TT></B>
	<BLOCKQUOTE>
	displays the value of the expression
	</BLOCKQUOTE>

<B><TT>exec filename</TT></B>
	<BLOCKQUOTE>
	reads and executes the script from a file, <TT>filename</TT>
	is a quoted string.
	</BLOCKQUOTE>

<B><TT>debug flag val</TT></B>
	<BLOCKQUOTE>
	sets debug-flag <TT>flag</TT> to (integer) value <TT>val</TT>. 
	If <TT>val=0</TT> the corresponding debug-info are
	turned off. <TT>flag</TT> can be: <TT>parse</TT>, <TT>tree</TT>, 
	<TT>rmidi</TT> and <TT>filt</TT>
	</BLOCKQUOTE>

<B><TT>panic</TT></B>
	<BLOCKQUOTE>
	causes the sequencer to core-dump
	</BLOCKQUOTE>
	
<HR>
<SMALL><EM>
Copyright (c) 2003-2005 Alexandre Ratchov<BR>
Last updated apr 6, 2005 	
</EM></SMALL>

</BODY>
</HTML>
