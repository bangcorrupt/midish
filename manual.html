<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!--
/*
 * Copyright (c) 2003-2007 Alexandre Ratchov <alex@caoua.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *      - Redistributions of source code must retain the above
 *        copyright notice, this list of conditions and the
 *        following disclaimer.
 *
 *      - Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the
 *        following disclaimer in the documentation and/or other
 *        materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-->

<HTML>
<HEAD>
<TITLE>midish 0.4 - User's manual and tutorial</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<META name="language" content="en">
</HEAD>
<BODY>

<!-- toc_begin - automatically generated, don't modify -->
<h1>Table of contents</h1>
	<UL>
	<LI><A href="#intro">1 Introduction</A>
	<UL>
	<LI><A href="#section_1_1">1.1 What is midish?</A>
	<LI><A href="#install">1.2 Installation</A>
	<LI><A href="#section_1_3">1.3 Invocation</A>
	<LI><A href="#section_1_4">1.4 How does it work</A>
	<LI><A href="#section_1_5">1.5 An example</A>
	</UL>
	<LI><A href="#dev">2 Devices setup</A>
	<LI><A href="#chan">3 Channels</A>
	<UL>
	<LI><A href="#section_3_1">3.1 Channel configuration</A>
	</UL>
	<LI><A href="#filt">4 Filtering/routing</A>
	<UL>
	<LI><A href="#section_4_1">4.1 About filters</A>
	<LI><A href="#section_4_2">4.2 Examples</A>
	<UL>
	<LI><A href="#section_4_2_1">4.2.1 Device redirections</A>
	<LI><A href="#section_4_2_2">4.2.2 Channel maps</A>
	<LI><A href="#section_4_2_3">4.2.3 Controller maps</A>
	<LI><A href="#section_4_2_4">4.2.4 Transpose</A>
	<LI><A href="#section_4_2_5">4.2.5 Keyboard splits</A>
	</UL>
	</UL>
	<LI><A href="#time">5 Time structure</A>
	<UL>
	<LI><A href="#section_5_1">5.1 Metronome</A>
	<LI><A href="#section_5_2">5.2 Time signature changes</A>
	<LI><A href="#section_5_3">5.3 Tempo changes</A>
	<LI><A href="#section_5_4">5.4 Moving within the song</A>
	</UL>
	<LI><A href="#track">6 Tracks</A>
	<UL>
	<LI><A href="#section_6_1">6.1 Recording a track without a filter</A>
	<LI><A href="#section_6_2">6.2 Recording a track with a filter</A>
	<LI><A href="#section_6_3">6.3 Basic editing of a track</A>
	<LI><A href="#section_6_4">6.4 Track quantization</A>
	<LI><A href="#section_6_5">6.5 Checking a track</A>
	</UL>
	<LI><A href="#frames">7 Frames, more about filtering and editing</A>
	<UL>
	<LI><A href="#section_7_1">7.1 Note frames</A>
	<LI><A href="#section_7_2">7.2 Pitch bend frames</A>
	<LI><A href="#ctl_frames">7.3 Controller frames</A>
	<LI><A href="#section_7_4">7.4 Other frames</A>
	</UL>
	<LI><A href="#sysex">8 System exclusive messages</A>
	<LI><A href="#info">9 Obtaining information</A>
	<LI><A href="#save">10 Saving and loading songs</A>
	<LI><A href="#export">11 Import/export standard MIDI files</A>
	<LI><A href="#interpreter">12 The interpreter's language</A>
	<UL>
	<LI><A href="#section_12_1">12.1 Global variables</A>
	<LI><A href="#section_12_2">12.2 Defining simple procedures</A>
	</UL>
	<LI><A href="#changes">13 Changes</A>
	<UL>
	<LI><A href="#changes_02">13.1 Changes from release 0.1 to release 0.2</A>
	<LI><A href="#changes_03">13.2 Changes from release 0.2 to release 0.3</A>
	<LI><A href="#changes_04">13.3 Changes from release 0.3 to release 0.4</A>
	</UL>
	<LI><A href="#attributes">14 Project attributes</A>
	<UL>
	<LI><A href="#section_14_1">14.1 Device attributes</A>
	<LI><A href="#section_14_2">14.2 Channel attributes</A>
	<LI><A href="#section_14_3">14.3 Filter attributes</A>
	<LI><A href="#section_14_4">14.4 Track attributes</A>
	<LI><A href="#section_14_5">14.5 Sysex attributes</A>
	<LI><A href="#section_14_6">14.6 Song attributes</A>
	</UL>
	<LI><A href="#ev">15 Events and event ranges specification</A>
	<UL>
	<LI><A href="#ev_ev">15.1 Event specification</A>
	<LI><A href="#ev_evspec">15.2 Event ranges specification</A>
	</UL>
	<LI><A href="#language">16 Language reference</A>
	<UL>
	<LI><A href="#section_16_1">16.1 Lexical structure</A>
	<LI><A href="#section_16_2">16.2 Statements</A>
	<LI><A href="#section_16_3">16.3 Expressions</A>
	<LI><A href="#section_16_4">16.4 Procedure definition</A>
	</UL>
	<LI><A href="#functs">17 Function reference</A>
	<UL>
	<LI><A href="#section_17_1">17.1 Track functions</A>
	<LI><A href="#section_17_2">17.2 Channel functions</A>
	<LI><A href="#section_17_3">17.3 Filter functions</A>
	<LI><A href="#section_17_4">17.4 System exclusive messages functions</A>
	<LI><A href="#section_17_5">17.5 Real-time functions</A>
	<LI><A href="#section_17_6">17.6 Song functions</A>
	<LI><A href="#section_17_7">17.7 Device functions</A>
	<LI><A href="#section_17_8">17.8 Controller functions</A>
	<LI><A href="#section_17_9">17.9 Misc. functions</A>
	</UL>
	<LI><A href="#section_18">18 Using midish in other programs</A>
	<LI><A href="#midishrc">19 Sample midishrc-file</A>
	<LI><A href="#example">20 Example sessions</A>
	<UL>
	<LI><A href="#section_20_1">20.1 Example - MIDI filtering</A>
	<LI><A href="#section_20_2">20.2 Example - recording a track</A>
	</UL>
	<LI><A href="#section_21">21 Thanks</A>
	</UL>
<!-- toc_end -->

<A name="intro"></A><H1>1 Introduction</H1>
<A name="section_1_1"></A><H2>1.1 What is midish?</H2>

        Midish is an open-source MIDI sequencer/filter for
        Unix-like operating systems (tested on OpenBSD and Linux).
        Implemented as a simple command-line interpreter (like a shell)
        it's intended to be <I>lightweight</I>,
        <I>fast</I> and <I>reliable</I> for
        real-time performance.
        <P>
        Important features:

        <UL>
        <LI>    real-time MIDI filtering/routing (controller mapping, keyboard splitting, ...)
        <LI>    track recording, metronome
        <LI>    track editing (insert, copy, delete, ...)
        <LI>    progressive track quantization
        <LI>    multiple MIDI devices handling
        <LI>    synchronization to external MIDI devices
        <LI>    import and export of standard MIDI files
        <LI>    tempo and time-signature changes
        <LI>    system exclusive messages handling
        </UL>

	<P>
        Midish is open-source software distributed under
        a 2-clause BSD-style license.

<A name="install"></A><H2>1.2 Installation</H2>

        Requirements:
        <UL>
        <LI>    a MIDI sound module
        <LI>    a MIDI keyboard
        <LI>    a POSIX unix-like operating system with "raw" MIDI support.
                Works on OpenBSD (its development platform)
                and Linux.
        <LI>    the readline(3) library
        </UL>

        (without any MIDI devices midish will be probably useless).
        <P>
        To install midish:

        <OL>
        <LI> Untar and gunzip the tar-ball:

        <PRE>
        gunzip midish-0.4.tar.gz
        tar -xf midish-0.4.tar
        cd midish-0.4
	</PRE>

        <LI>
       	Edit Makefile and change the readline(3) options in Makefile

        <LI>
        Compile midish, just type "<TT>make all</TT>", this will build
        midish and rmidish, the readline(3) front-end to midish.

        <LI>
        Install binaries, documentation and examples by
        typing "<TT>make install</TT>". They are copied as follows:
        <UL>
        <LI> binaries in <TT>PREFIX/bin</TT>
        <LI> manual pages in <TT>PREFIX/man/man1</TT>
        <LI> html documentation in <TT>PREFIX/share/doc/midish</TT>
        <LI> example files in <TT>PREFIX/share/examples/midish</TT>
        where <TT>PREFIX</TT> is by default <TT>/usr/local</TT>.
        To change this, set the <TT>PREFIX</TT> variable in
        <TT>Makefile</TT>, for instance:

        <PRE>
        make PREFIX=$HOME install
        </PRE>
        </UL>
        <LI>
        If there isn't a <TT>/etc/midishrc</TT> file,
	then copy the sample file by
        typing "<TT>cp midishrc /etc</TT>" in your shell.
        <LI>
        Read the documentation and modify <TT>/etc/midishrc</TT> in order
        to choose the default MIDI device by using the <TT>devattach</TT>
        function, example:
	<PRE>
	devattach 0 "/dev/rmidi3" rw
	</PRE>
	see next section for details.
        </OL>


<A name="section_1_3"></A><H2>1.3 Invocation</H2>
        <P>
        Midish is a MIDI sequencer/filter driven by a command-line
        interpreter (like a shell).

        Once midish started, the interpreter prompts
        for commands.

        Then, it can be used to configure MIDI devices,
        create tracks, define channel/controller mappings,
        route events from one device to another, play/record a song etc.

        To start midish, just type:
        <PRE>
        rmidish
        </PRE>

        Then, commands are issued interactively on the midish prompt,
        example:
        <PRE>
        print "hello world"
        </PRE>

        <P>
        Once MIDI devices are setup, one of the performance modes
	can be started or stopped with one of the following commands:
	<ul>

	<li>
	songidle - open MIDI devices but do nothing, just process
	input and send it to the output.

	<li>
	songplay - open MIDI devices and start playback

	<li>
	songrecord - open MIDI devices and start playback and
	recording

	<li>
	songstop - stop one of the above and close MIDI devices.
	</ul>

	In performance mode certain features are not available (like
	most editing functions).

	Thus performance mode should be disabled; furthermore MIDI
	devices are closed and thus are available to other
	applications.

<A name="section_1_4"></A><H2>1.4 How does it work</H2>
Midish uses the following objects to represent a project:

<UL>
<LI><B>MIDI devices:</B><BR>
        these are actual MIDI devices (keyboards, sound modules,
        external sequencers...) from which events are received and/or to which
        they are sent.

<LI><B>Filters:</B><BR>
        a filter is a set of rules that says which MIDI event to discard
        and how to transform incoming events. The filter also "sanitizes" the
        input MIDI stream by removing nested notes, duplicate controllers and
        other anomalies.

<LI><B>Channels:</B><BR>
        a channel is an a output <TT>{device&nbsp;midichannel}</TT> pair that
        represent an instrument. A channel holds some properties like patch
        number, volume, reverb depth or other controllers.

<LI><B>Tracks:</B><BR>
        tracks represent pieces of music: they hold MIDI voice events
        (notes, controllers ...). Tracks aren't bound to a particular
        channel and can contain events from any channel.

<LI><B>Sysex banks:</B> <BR>
        a sysex bank is a set of system exclusive messages. They
        will be sent to MIDI devices when performance mode is entered.

<LI><B>The "meta-track":</B><BR>
        it is a particular hidden track that contains
        only special events like tempo changes and time signature changes.

<LI><B>Song parameters</B>: <BR>
        these are miscellaneous parameters like the
        metronome configuration, the current selection...
</UL>

The above objects are grouped in a <I>project</I> (a song) and manipulated
in prompt mode by issuing interactively commands.

<P>
Performance mode is used to play/record the project. When performance
mode is entered, MIDI devices are opened, and all sysex messages and
channel configuration events are sent to them. There are three
performance modes:

<UL>
<LI><B>"Idle" mode</B><BR>
        The MIDI input passes through the <I>current filter</I>
        and the result is sent to the midi output. No tracks are
        played or recorded.
        <PRE>
        +---------+             +------------+          +----------+
        |         |             |            |          |          |
        | MIDI in |-------------|   filter   |---------&gt;| MIDI out |
        |         |             |            |          |          |
        +---------+             +------------+          +----------+
        </PRE>

<LI><B>Play mode</B><BR>
        The MIDI input passes through the <I>current filter</I>
        the result is mixed with the currently played tracks
        and finally sent to the MIDI output. No tracks are recorded.
        <PRE>
                                +--------------+
                                | track_1 play |---\
                                +--------------+   |
                                                   |
                                     ...        ---+
                                                   |
                                +--------------+   |
                                | track_N play |---+
                                +--------------+   |
                                                   |
        +---------+             +------------+     |    +----------+
        |         |             |            |     \---&gt;|          |
        | MIDI in |------------&gt;|   filter   |---------&gt;| MIDI out |
        |         |             |            |          |          |
        +---------+             +------------+          +----------+
        </PRE>

<LI><B>Record mode</B><BR>
        The MIDI input passes through the <I>current filter</I>
        and is recorded to the <I>current track</I>.
        The result is mixed with the currently played tracks
        and finally sent to the MIDI output. System exclusive
        messages are recorded to the <I>current sysex</I> without
        being passed through the filter.
        <PRE>
                                +--------------+
                                | track_1 play |---\
                                +--------------+   |
                                                   |
                                     ...        ---+
                                                   |
                                +--------------+   |
                                | track_N play |---+
                                +--------------+   |
                                                   |
        +---------+             +------------+     |    +----------+
        |         |             |            |     \---&gt;|          |
        | MIDI in |-----+------&gt;|   filter   |----+----&gt;| MIDI out |
        |         |     |       |            |    |     |          |
        +---------+     |       +------------+    |     +----------+
                        |                         |
                        |                         |     +----------------+
                        |       +--------------+  \----&gt;| track_X record |
                        \------&gt;| sysex record |        +----------------+
                                +--------------+
        </PRE>
</UL>

The above performance modes are started respectively with
<TT>songidle</TT>, <TT>songplay</TT>, <TT>songrecord</TT>.

Certain functions are not available during performance mode; to stop
it, use the <TT>songstop</TT> function.


<A name="section_1_5"></A><H2>1.5 An example</H2>

	Suppose that there are two devices:
		<UL>
		<LI><TT>/dev/rmidi4</TT> - a MIDI sound module
		<LI><TT>/dev/rmidi3</TT> - a MIDI keyboard
		</UL>
	Thus, the <TT>/etc/midishrc</TT> file contains the
	following lines:
	<PRE>
	devattach 0 "/dev/rmidi4" rw	# attach the module as dev number 0
	devattach 1 "/dev/rmidi3" rw	# attach the keyboard as dev number 1
	</PRE>

	the <TT>rw</TT> means that the device will be opened in
	read-write mode.
	The following session shows how to  record a simple track.
	First, we define a filter  named <TT>piano</TT> that
	routes events from device 1, channel 0 (input channel of
	the keyboard) to device 0, channel 5  (output channel of
	the sound module). Then we create a new track
	<TT>pi1</TT>, we start recording and we save the song
	into a file.
	<PRE>
	1&gt; filtnew piano			# create filter "piano"
	2&gt; filtchanmap piano {1 0} {0 5}	# dev=1,ch=0 -&gt; dev=0,ch=5
	3&gt; tracknew pi1				# create track "pi1"
	4&gt; songrecord				# start recording
	5&gt; songstop				# stop recording
	6&gt; songsave "mysong"			# save the song into a file
	7&gt;					# EOF (control-D) to quit
	</PRE>

	<P>
	The same task can be achieved in a much easier way
	by using the simple procedures (or macros) defined in the
	default <TT>/etc/midishrc</TT>.
	<PRE>
	1&gt; ci {1 0}			# select default input {dev, chan}
	2&gt; ni piano {0 5}		# create piano on dev=0, chan=5
	3&gt; nt pi1 			# new track named "pi1"
	4&gt; r				# start recording
	5&gt; s				# stop recording
	6&gt; save "mysong"		# save to file "mysong"
	7&gt;				# EOF (control-D) to quit
	</PRE>

	<P>
	<B>Note:</B>
	It is strongly recommended to define simple procedures
	and to use them instead of directly using the built-in functions
	of midish.

<A name="dev"></A><H1>2 Devices setup</H1>

        In midish, MIDI devices are numbered from 0 to 15.
        Each MIDI device has its "slot number". For instance,
        suppose that there is a MIDI sound module known as
        <TT>/dev/rmidi3</TT> and a MIDI keyboard known as
        <TT>/dev/rmidi4</TT>.

        The following commands will configure the module as
        device number 0 and
        the keyboard as device number 1:
        <PRE>
        devattach 0 "/dev/rmidi4" rw
        devattach 1 "/dev/rmidi3" rw
        </PRE>

        <P>
        <B>Note:</B>
        To make easier the import/export procedure from systems
        with different configurations, it's strongly recommended to
        attach the main sound module (the mostly used one)
        as device number 0.

        <P>
        In order to check that the sound module is properly configured
        play the demo song:
        <PRE>
        songload "sample.sng"
        songplay
	songstop
        </PRE>

        When the configuration is setup, put the "devattach"
        commands in the user's <TT>$HOME/.midishrc</TT>. It will be
        automatically executed the next time midish is run.


<A name="chan"></A><H1>3 Channels</H1>

        Because midish handles multiple devices, instead of
        using MIDI channels, it uses device / MIDI channel pairs
        to represent instruments.

        So <I>channel</I> refers the device / MIDI channel pair.

        Channels are handled by two-item lists, like this:
        <PRE>
        {0 1}                   # device 0, MIDI channel 1
        </PRE>
        Channels can also be named, as follows:
        <PRE>
        channew mybass {0 1}
        </PRE>
        this defines a named-channel <TT>mybass</TT> that can
        be used instead of the <TT>{0 1}</TT> pair.

<A name="section_3_1"></A><H2>3.1 Channel configuration</H2>

        A channel represents one musical instrument;
        midish allows to attach to the channel definition
        basic "configuration" events like program changes and
        controllers.

        Such events are sent to the output when performance mode is entered,
        for instance just before playback is started. This approach avoids
        flooding MIDI devices with "slow" events (like
        program changes).

        <P>
        For instance;
        to select patch 34 on channel <TT>mybass</TT>, attach
        a "program change" event:
        <PRE>
        chanconfev mybass {pc mybass 32}
        </PRE>
        the list-argument gives the event to attach to the channel.
        See the <A href="#ev_ev">event</A> section for
        more details about events.

        <P>
        To set the volume (controller 7) of this channel to 120:
        <PRE>
        chanconfev mybass {ctl mybass 7 120}
        </PRE>
        If several events of the same type are attached
        then just the last one is kept. So, the following
        will change the volume to 125 by replacing the above event:
        <PRE>
        chanconfev mybass {ctl mybass 7 125}
        </PRE>



<A name="filt"></A><H1>4 Filtering/routing</H1>

        <P>
        Midish supports MIDI filtering: a <I>filter</I>
        transforms incoming MIDI events and send them to the
        output. The filter also "sanitizes" the input MIDI stream
        by removing nested notes, duplicate controllers and other
        anomalies.

        Filters are in general used to:
        <UL>
        <LI>
        route events from a device/channel to another
        <LI>
        map a controller to another
        <LI>
        split the keyboard
        <LI>
        drop unwanted events
        <LI>
        etc...
        </UL>


<A name="section_4_1"></A><H2>4.1 About filters</H2>
        <P>
        Multiple filters can be defined, however only the
        <I>current filter</I> will run in performance
        mode.

        If no filters are defined or if there is no current filter
        then, in performance mode, input is sent to the output as-is.

        The current filter processes input MIDI events in the
        following order:
        <OL>
        <LI>    First, input events are checked for inconsistencies: nested
                note-on, orphaned note-off and duplicate controller, bender
                and aftertouch events are removed.
                Zero-length notes are lengthened to one "tick".
                The rate of controller, bender and aftertouch events is
                normalized in order not to flood output devices.

        <LI>    The input event is checked against all <I>voice rules</I>
                and the resulting events (if any) are sent to the output of
                the filter (if the event matches more than one <I>voice
                rule</I> then it is duplicated if needed).

        <LI>    If the input didn't match any <I>voice rule</I> then it is
                checked against all <I>channel rules</I> and the resulting
                events (if any) are sent to the output of the filter.  (if
                the event matches more than one <I>channel rule</I> then it
                is duplicated if needed).

        <LI>    If the input event didn't match any <I>channel rule</I> then
                it is checked against all <I>device rules</I> and the
                resulting events (if any) are sent to the output of the
                filter (if several <I>device rules</I> match the input event
                then it is duplicated if needed).

        <LI>    Finally, if the input event didn't match any <I>device
                rule</I> then it is passed to the output of the filter
                as-is.

        </OL>

        <P>
        The following diagram summarizes the event path through the filter:
        <PRE>
                +------------+
                |   voice    | match
        in ----&gt;|            |-----------------------------------------&gt; out
                |   rules    |
                +------------+
              doesn't |         +------------+
                match |         |  channel   | match
                      \--------&gt;|            |-------------------------&gt; out
                                |   rules    |
                                +------------+
                              doesn't |         +------------+
                                match |         |   device   | match
                                      \--------&gt;|            |---------&gt; out
                                                |   rules    |
                                                +------------+
                                              doesn't |
                                                match |
                                                      \----------------&gt; out

        </PRE>

        <P>
        Filters are defined as follows:
        <PRE>
        filtnew myfilt                  # define filter "myfilt"
        </PRE>
        initially the filter is empty and will send input to output
        as-is.

        Once the filter is created, filtering rules can be added,
        modified and removed.
        See
        <A href="#func_filt">filtering functions</A> section
        for details.

        <P>
        Rules can be listed with <TT>filtinfo</TT>.
        All filtering rules can be removed with <TT>filtreset</TT>.


<A name="section_4_2"></A><H2>4.2 Examples</H2>

<A name="section_4_2_1"></A><H3>4.2.1 Device redirections</H3>

        The following example defines a filter that routes events from
        device number 1 (the MIDI keyboard) to device number 0
        (the sound module).
        <PRE>
        filtnew mydevmap                # define filter "mydevmap"
        filtdevmap mydevmap 1 0         # make it route device 1 -&gt; device 0
        </PRE>
        To test the filter, start performance mode:
        <PRE>
        songidle
        </PRE>
	(type "songstop" to stop performance mode).

<A name="section_4_2_2"></A><H3>4.2.2 Channel maps</H3>

        The following example defines a filter
        that routes events from device 1, channel 0
        (first channel of the keyboard) to device 0, channel 9
        (default drum channel of the sound module).
        <PRE>
        filtnew mydrums                 # define filter "mydrums"
        filtchanmap mydrums {1 0} {0 9} # route dev/chan {1 0} to {0 9}
        </PRE>
        The device/channel pair is in braces. The first <TT>{1 0}</TT>
        is the input device/channel and <TT>{0 9}</TT> is the output channel.
        To test the filter, start performance mode:
        <PRE>
        songidle
        </PRE>
	(type "songstop" to stop performance mode).
        Playing on channel 0 of the keyboard will make
        sound channel 9 of the sound-module.

<A name="section_4_2_3"></A><H3>4.2.3 Controller maps</H3>

        The following example add a new rule to the above filter
        that maps the modulation wheel (controller 1) of
        the source channel (ie device 1, channel 0)
        to the expression controller (number 11) of
        the destination channel (device 0, channel 9).
        <PRE>
        filtctlmap mydrums {1 0} {0 9} 1 11
        </PRE>
        the first three arguments are the name of the filter,
        the input and the output device/channel pair. The 4-th
        argument is the controller number on the input (1 = modulation)
        and the 5-th argument is the controller number
        on the output (11 = expression).
        Rules of the filter can be listed as follows:
        <PRE>
        filtinfo mydrums
        </PRE>
        which will print:
        <PRE>
        {
                chanmap {1 0} {0 9}
                ctlmap {1 0} {0 9} 1 11 id
        }
        </PRE>

<A name="section_4_2_4"></A><H3>4.2.4 Transpose</H3>

        The following example transposes by 12 half-tones
        (one octave) notes on device 1, channel 0 (keyboard) and
        sends them on device 0 channel 2 (sound-module).
        <PRE>
        filtnew mypiano                 # define filter "mypiano"
        filtchanmap mypiano {1 0} {0 2} # route dev/chan {1 0} to {0 9}
        filtkeymap  mypiano {1 0} {0 2} 0 127 12
        </PRE>
        both rules are necessary. Note events are handled by
        the key-rule and other events (controllers) fall trough
        the channel-rule. Arguments 4 and 5 to <TT>filtkeymap</TT>
        give the note range that will be handled
        (from 0 to 127, i.e. the whole keyboard)
        and the 6-th argument gives the number of half-tones
        (12, one octave) to transpose.

<A name="section_4_2_5"></A><H3>4.2.5 Keyboard splits</H3>

        In the same way it is possible to create a keyboard-split with two
        key-rules and two channel-rules.
        The following example splits the
        keyboard in two parts (left and right) on note 64 (note E3, the
        middle of the keyboard).
        Notes on the left part  will be routed to
        channel 3 of the sound module and notes on the right
        part will be routed to channel 2 of the sound module.
        <PRE>
        filtnew mysplit
        filtchanmap mysplit {1 0} {0 2}
        filtkeymap mysplit  {1 0} {0 2} 0  63  0
        filtchanmap mysplit {1 0} {0 3}
        filtkeymap mysplit  {1 0} {0 3} 64 127 0
        </PRE>
        <P>
        Defining filters seems quite tedious, however it's possible
        to define procedures that do the same in a very simpler way.
        See the <A href="#interpreter">interpreter language</A>
        for more details.


<A name="time"></A><H1>5 Time structure</H1>

        <P>
        In midish, time is split in <I>measures</I>. Each measure
        is split in <I>beats</I> and each beat is split in
        <I>ticks</I>. The <I>tick</I> is the fundamental
        time unit in midish. Duration of ticks is fixed
        by the <I>tempo</I>. By default midish uses:
                <UL>
                <LI>24 ticks per beat
                <LI>4 beats per measure
                <LI>120 beats per minute
                </UL>
        From the musical point of view, a beat often corresponds to
        a quarter note, to an eight note etc...
        By default
        an unit note corresponds to 96 ticks, thus by default
        one beat corresponds to one quarter note, i.e.
        the time signature is 4/4.


<A name="section_5_1"></A><H2>5.1 Metronome</H2>

        In order to "hear" time, a metronome can be used. It is
        used only in play and record modes. It produces
        a click sound on every beat. To start the metronome:
        <PRE>
        metroswitch 1           # switch the metronome on
        songplay                # start playback
	songstop		# stop
        </PRE>
        The metronome has two kind of click-sound:
        <UL>
        <LI> high-click: on the first beat of the measure
        <LI> low-click: on the other beats.
        </UL>
        The click-sound can be configured by giving a couple
        of note-on events, as follows:
        <PRE>
        metroconf {non {0 9} 48 127} {non {0 9} 64 100}
        </PRE>
        this configures the high-click with note 48, velocity 127 on
        device 0, channel 9 and the low-click with note 64, velocity 100
        on device 0, channel 9.

<A name="section_5_2"></A><H2>5.2 Time signature changes</H2>

        Time signature changes are achieved by inserting or
        deleting measures. The following starts
        a song with time signature of 4/4 (at measure 0) and
        change the time signature to 6/8 at measure 2 during
        5 measures:
        <PRE>
        songtimeins 0 2 4 4     # 4/4 at measure 0 during 2 measures
        songtimeins 2 5 6 8     # 8/6 at measure 2 during 5 measures
        metroswitch 1           # switch the metronome on
        songplay                # test it
	songstop
        </PRE>
        To suppress measure number 2 (the first 6/8 measure)
        <PRE>
        songtimerm  2 1         # remove 1 measure starting a measure 2
        metroswitch 1           # switch the metronome on
        songplay                # test it
	songstop
        </PRE>

	<p>
	To get the time signature at any given measure number,
	the 'songgetsign' function can be used. It returns
	the denominator and the numerator in a two integer list.
	For instance,
	to print the time signature at measure number 17:
	<pre>
        print [songgetsign 17]
	</pre>

<A name="section_5_3"></A><H2>5.3 Tempo changes</H2>

        Tempo changes are achieved simply by giving the measure
        number and the tempo value in beats per minute. For
        instance, the following changes tempo on measure 0
        to 100 beats per minute and on measure 2 to 180 beats
        per minute.
        <PRE>
        songsettempo 0 100
        songsettempo 2 180
        </PRE>

	<p>
	To get the tempo at any given measure number,
	the 'songgettempo' function can be used. It returns
	the tempo in beats per minute. For instance,
	to print the tempo at measure number 17:
	<pre>
        print [songgettempo 17]
	</pre>


<A name="section_5_4"></A><H2>5.4 Moving within the song</H2>

        The following selects the current position in the song to
        measure number 3:
        <PRE>
        songsetcurpos 3
        </PRE>
        This will make <TT>songrecord</TT> and <TT>songplay</TT>
        start at this particular position instead of measure
        number 0.

<A name="track"></A><H1>6 Tracks</H1>

        <P>
        A track is a piece of music, namely an ordered in time list
        of MIDI events. In play mode, midish play simultaneously
        all defined tracks, in record-mode it plays all defined tracks
        and records the current track.

        <P>
        Tracks aren't assigned to any particular device/channel; a track
        can contain MIDI data from any device/channel. A track can have its
        <I>current filter</I>; in this case, MIDI events
        are passed through that filter before being recorded. If the
        track has no current filter, then the song current
        filter is used instead. If there is neither track current
        filter nor song current filter, then MIDI events
        from all devices are recorded as-is.

<A name="section_6_1"></A><H2>6.1 Recording a track without a filter</H2>

        <P>
        The following defines a track and record events
        as-is from all MIDI devices:
        <PRE>
        tracknew mytrack
        songrecord
	songstop
        </PRE>
        tracks are played as follows:
        <PRE>
        songplay
	songstop
        </PRE>
        However, with the above configuration this will not
        work as expected because events from the input
        keyboard (device number 1) will be recorded as-is and then
        sent back to the device number 1 instead of being sent
        to the sound module (device number 0).

<A name="section_6_2"></A><H2>6.2 Recording a track with a filter</H2>

        The following creates a filter and uses it to
        record to the above track:
        <PRE>
        filtnew mypiano
        filtchanmap mypiano {1 0} {0 0}         # dev1/chan0 -&gt; dev0/chan0
        tracknew mytrack
        songrecord
        </PRE>

<A name="section_6_3"></A><H2>6.3 Basic editing of a track</H2>

        <P>
        Most track editing functions in midish take at least the
        following arguments:
        <UL>
        <LI> start measure
        <LI> number of measures
        <LI> precision/quantum (in ticks).
        </UL>
        For instance to blank measure number 3 of
        track <TT>mypiano</TT>:
        <PRE>
        trackblank mypiano 3 1 (96 / 16) {}
        </PRE>
        the 3-rd argument set the precision to sixteenth note
        (assuming 96 ticks per unit note). This
        means that notes position is rounded to the nearest 16-th note
        before being removed.
        This is useful, because often recorded notes
        doesn't start exactly on the measure boundary. The precision
        argument makes possible to edit a track that is not quantized.
        The latest argument (empty list) selects the events to be
        deleted (see section <A href="#ev_evspec">event ranges</A>).

        <P>
        In a similar way, one can cut a piece of a track,
        for instance to cut 2 measures starting
        at measure number 5:
        <PRE>
        trackcut mypiano 5 2 (96 / 16)
        </PRE>

        <P>
        The following inserts 2 blank measures at
        measure number 3:
        <PRE>
        trackinsert mypiano 3 2 (96 / 16)
        </PRE>

        <P>
        A track portion can be copied into
        another track as follows:
        <PRE>
        trackcopy mypiano 3 2 mypiano2 5 (96 / 16) {}
        </PRE>
        this will copy 2 measures starting from measure
        number 3 into (the already existing) track <TT>mypiano2</TT>
        at measure 5.
        The latest argument (empty list) selects the events to be
        copied (see section <A href="#ev_evspec">event ranges</A>).


<A name="section_6_4"></A><H2>6.4 Track quantization</H2>

        A track can be quantized by rounding note-positions
        to the nearest exact position. The following
        will quantize 4 measures starting at measure number
        3 by rounding notes to the nearest quarter note.
        <PRE>
        trackquant mypiano 3 4 (96 / 4) 75
        </PRE>
        The last arguments gives the percent of quantization.
        100% means full quantization and 0% leans no
        quantization at all. This is useful because full quantization
        often sound to regular especially on acoustic patches.


<A name="section_6_5"></A><H2>6.5 Checking a track</H2>

        It is possible that a MIDI device transmits
        bogus MIDI data. The following scans the track
        and removes bogus notes
        and unused controller events:
        <PRE>
        trackcheck mytrack
        </PRE>
        This function can be useful to remove
        nested notes when a track is recorded twice (or more)
        without being erased.


<A name="frames"></A><H1>7 Frames, more about filtering and editing</H1>

	In midish, MIDI events are packed into <I>frames</I>. For
	instance a note-on event followed by a note-off with the same
	note number constitute a <I>frame</I>. All filtering and
	editing functions work on frames, not on events. That means
	that all events within a frame are processed consistently. For
	instance, deleting a note-on event will also delete related
	note-off and key-aftertouch events. This ensures full
	consistency of tracks and MIDI I/O streams.

<A name="section_7_1"></A><H2>7.1 Note frames</H2>

	Note frames are made of a starting "non" event any optional
	"kat" events and the stopping "noff" event. In editing functions
	note frames are copied/moved/deleted as a whole; they are never
	truncated. The starting event (note on) determines whether
	the frame is selected. For instance, in
	<a href="#func_trackblank">trackblank</a> function, only
	note frames whose "non" events are in the selected region
	are erased.

	<P>
	Conflicting note frames (ie with the same note number)
	are never merged. An attempt to copy a note frame on
	the top of a second one will erase the second one. This avoids
	having nested notes.

<A name="section_7_2"></A><H2>7.2 Pitch bend frames</H2>

	<P>
	A pitch bend frame is made of "bend" events. It starts with
	a "bend" event whose value is different from the default value
	(ie different from 0x3FFF). It stops when the value reaches
	the default value of 0x3FFF. In editing functions a "bend"
	frame may be truncated or split into multiple frames, however
	resulting frames always terminate with the default value. For
	instance, <a href="#func_trackblank">trackblank</a> may erase
	the middle of "bend" frame resulting in two new "bend" frame
	(the beginning and the ending of the old one).

	<P>
	Conflicting "bend" frames are merged. An attempt to copy a
	frame on top of another one will overwrite conflicting
	regions of the second one and "glue" the rest; this will
	result in a single frame, containing chunks of both original
	frames.

<A name="ctl_frames"></A><H2>7.3 Controller frames</H2>

	The way controller events are packed in a frame depend
	on the controller type. Currently the following
	controllers are supported:
	<UL>
	<LI>
		<B>Parameters:</B> this controller change a parameter
		of the channel but it doesn't have a special default
		value. For instance volume controller, reverb depth
		etc... These controllers are not packed together, they
		form single event frames. This is the default behavior
		for most controllers.

	<LI>
		<B>Frames:</B> these are controllers that have special
		default value and that are packed in frames, similar
		to "bend" frames. For instance modulation wheel,
		sustain pedal. For those frames special care is taken
		in editing functions.

	</UL>

	The user can specify for each controller number the desired
	behavior.
	The <a href="#func_ctlconf">ctlconf</a> function
	configures the controller. As arguments, it takes the name of
	the controller (an identifier) the controller number and the
	default value of the controller.
	If the default value is <TT>nil</TT> (ie no default value),
	then the controller is considered as of type <I>parameter</I>.
	For instance, following command:
        <PRE>
        ctlconf expr 11 127
        </PRE>
	configures controller number 11 of type <I>frame</I> and with
	default value of 127. The controller name can be
	any identifier, it can be used for other functions to
	reference a controller.
	The <a href="#func_ctlconf">ctlinfo</a> function
	can be used to display the current configuration
	of all controllers:
        <PRE>
	ctltab {
	        #
	        # name  number  defval
		#
	        mod     1       0
	        vol     7       nil
		sustain 64      0
	}
        </PRE>

<A name="section_7_4"></A><H2>7.4 Other frames</H2>

	<P>
	Channel aftertouch events are packed in channel aftertouch
	frames. They behave exactly as pitch bender frames, except
	that the default value is zero.

	<P>
	Program/bank change, NRPN and RPN events are not packed
	together, they are single event frames.

<A name="sysex"></A><H1>8 System exclusive messages</H1>

        Midish can send system exclusive messages
        to MIDI devices before starting performance mode.
        Typically, this feature can be used to change
        the configuration of MIDI devices. System
        exclusive (aka "sysex") messages are stored into
        named banks. To create a sysex bank named <TT>mybank</TT>:
        <PRE>
        sysexnew mybank
        </PRE>
        Then, messages can be added:
        <PRE>
        sysexadd mybank 0 {0xF0 0x7E 0x7F 0x09 0x01 0xF7}
        </PRE>
        This will store the "General-MIDI ON" messages into the
        bank. The second argument (here "0") is the device number
        to which the message will be sent when performance mode
        is entered. To send the latter messages to
        the corresponding device, just enter performance mode,
        for instance:
        <PRE>
        songidle
        </PRE>
        Sysex messages can be recorded from
        MIDI devices, this is useful to save "bulk dumps"
        from synthesizers. Sysex messages are automatically
        recorded on the <I>current bank</I>. So, to record
        a sysex:
        <PRE>
        songsetcursysex mybank
        songrecord
        </PRE>
        The next time performance mode is entered, recorded
        sysex messages will be sent back to the device.
        Information about the recorded sysex messages
        can be obtained as follows:
        <PRE>
        sysexinfo mybank
        </PRE>
        A bank can be cleared by:
        <PRE>
        sysexclear mybank {}
        </PRE>
        the second argument is a (empty) pattern, that matches
        any sysex message in the bank. The following will remove
        only sysex messages starting with 0xF0 0x7E 0x7F:
        <PRE>
        sysexclear mybank {0xF0 0x7E 0x7F}
        </PRE>
        Sysex messages recorded from any device can be configured
        to be sent to other devices. To change the device number
        of all messages to 1:
        <PRE>
        sysexsetunit mybank 1 {}
        </PRE>
        the second argument is an empty pattern, thus it matches
        any sysex message in the bank. The following will change
        the device number of only sysex messages starting
        with 0xF0 0x7E 0x7F:
        <PRE>
        sysexsetunit mybank 1 {0xF0 0x7E 0x7F}
        </PRE>

<A name="info"></A><H1>9 Obtaining information</H1>

        <P>
        The following functions gives some information
        about midish objects:
        <PRE>
        songinfo                        # summary
        songtimeinfo                    # tempo changes
        chaninfo mydrums                # list config. events in "mydrums"
        filtinfo myfilt                 # list rules in "myfilt"
        trackinfo mytrack (96 / 16) {}  # list number of events per measure
        devinfo 0                       # device properties
        </PRE>

        <P>
        Objects can be listed as follows:
        <PRE>
        print [tracklist]
        print [chanlist]
        print [filtlist]
        print [devlist]
        </PRE>

        <P>
        Current values can be obtained as follows:
        <PRE>
        print [songgetunit]             # ticks per unit note
        print [songgetcurpos]           # print current position
        print [songgetcurlen]           # print current selection length
        print [songgetcurfilt]          # current filter
        print [songgetcurtrack]         # current track
        print [songgetcursysex]
        print [trackgetcurfilt mypiano] # current filter of track "mypiano"
        print [filtgetcurchan mysplit]  # current channel of filter "mysplit"
        </PRE>

        <P>
        The device and the MIDI channel of a channel definition
        can be obtained as follows:
        <PRE>
        print [changetch mydrums]       # print midi chan number
        print [changetdev mydrums]      # print device number
        </PRE>

        <P>
        To check if object exists:
        <PRE>
        print [chanexists]
        print [filtexists]
        print [trackexists]
        print [sysexexists]
        </PRE>
        this will print 1 if the corresponding object exists
        and 0 otherwise.


<A name="save"></A><H1>10 Saving and loading songs</H1>

        <P>
        A song can be saved into a file. All channel definitions,
        filters, tracks, their properties,
        and values of the current track, current
        filter will be saved by:
        <PRE>
        songsave "myfile"
        </PRE>
        In a similar way, the song can be load from a file
        as follows:
        <PRE>
        songload "myfile"
        </PRE>

        <P>
        Note that the "local settings" (like device configuration,
        metronome settings) are not saved.

<A name="export"></A><H1>11 Import/export standard MIDI files</H1>

        <P>
        Standard MIDI files type 0 or 1 can be imported. Each
        track in the standard MIDI file corresponds to a track in midish.
        Tracks are named <TT>trk00</TT>, <TT>trk01</TT>, ...
        All MIDI events are assigned to device number 0. Only the following
        meta events are handled:
                <UL>
                <LI> tempo changes
                <LI> time signature changes
                </UL>
        all meta-events are removed from the "voice" tracks and
        are moved into the midish's meta-track. Finally tracks
        are checked for anomalies. Example:
        <PRE>
        songimportsmf "mysong.mid"
        </PRE>

        <P>
        Midish songs can be exported into standard MIDI files.
        Tempo changes and time signature changes are exported
        to a meta-track (first track of the MIDI file). Each
        channel definition is exported as a track containing
        the channel configuration events. Voice tracks
        are exported as is in separate tracks. Note that device
        numbers of MIDI events are not stored in the MIDI file
        because the file format does not allow this.
        Example:
        <PRE>
        songexportsmf "mysong.mid"
        </PRE>

<A name="interpreter"></A><H1>12 The interpreter's language</H1>

        <P>

        Even to achieve some simple tasks with midish, it's
        sometimes necessary to write several long statements.  To
        make midish more usable, it suggested to use variables
        and/or to define procedures, as follows.

<A name="section_12_1"></A><H2>12.1 Global variables</H2>

        <P>
        Variables can be used to store numbers, strings and
        references to tracks, channels and filters, like:

        <PRE>
        let x = 53              # store 53 into "x"
        print $x                # prints "53"
        </PRE>

        The <TT>let</TT> keyword is used to assign values to
        variables and the dollar sign ("<TT>$</TT>") is used
        to obtain variable values.

<A name="section_12_2"></A><H2>12.2 Defining simple procedures</H2>

        <P>
        For instance, let
        us create a procedure named "<TT>i</TT>" that just replaces
        <TT>songidle</TT> in order to avoid typing its name.
        <PRE>
        proc i {songidle;}
        </PRE>
        The <TT>proc</TT> keyword is followed by the procedure
        name and then follows a list of statements between
        braces. In a similar way can define the following
        procedures:
        <PRE>
        proc p {
                metroswitch 0           # turn off metronome
                songplay                # start playback
        }

        proc r {
                metroswitch 1           # turn on metronome
                songrecord              # start recording
        }
        </PRE>

        <P>
        Procedures can take arguments.
        For instance, to define a procedure named <TT>nt</TT>
        that creates a new track:
        <PRE>
	proc nt name {
		tracknew $name
	}
        </PRE>
        After the name of the procedure follows the argument names list
        that can be arbitrary identifiers. The value of an argument
        is obtained by preceding the variable name by the dollar
        sign ("$"). We can use the above procedure to create a track:
        <PRE>
        nt myfilt
        </PRE>

        A lot of similar procedures are defined in the
        sample <TT>midishrc</TT> file, shipped in the source
        tar-ball. To make midish easy to use, most of
        the usual tasks can be performed with only 2 or
        three character statements.

        <P>
        Procedure and variables definitions can be
        stored in the <TT>~/.midishrc</TT> file (or <TT>/etc/midishrc</TT>).
	It will be automatically executed the next time you run midish.


<A name="changes"></A><H1>13 Changes</H1>
<A name="changes_02"></A><H2>13.1 Changes from release 0.1 to release 0.2</H2>

        <UL>
        <LI> added <TT>device</TT> parameter to <TT>sendraw</TT>
        <LI> removed <TT>filtchangein</TT> and added
		<TT>filtchgich</TT>, <TT>filtchgidev</TT>,
		<TT>filtswapich</TT>, <TT>filtswapidev</TT>,
		<TT>filtchgoch</TT>, <TT>filtchgodev</TT>,
		<TT>filtswapoch</TT>, <TT>filtswapodev</TT>.
        <LI> added new filter rules:
                <TT>filtdevdrop</TT>,
                <TT>filtchandrop</TT>,
                <TT>filtctldrop</TT> and
                <TT>filtkeydrop</TT>.
        <LI> added functions that remove existing rules:
                <TT>filtnodevdrop</TT>,
                <TT>filtnodevmap</TT>,
                <TT>filtnochandrop</TT>,
                <TT>filtnochanmap</TT>,
                <TT>filtnoctldrop</TT>,
                <TT>filtnoctlmap</TT>,
                <TT>filtnokeydrop</TT> and
                <TT>filtnokeymap</TT>.
        <LI> added support for external MIDI synchronization,
             added <TT>devsetmaster</TT>, <TT>devgetmaster</TT>
             and <TT>devsendrt</TT>
        <LI> added
                <TT>trackdelete</TT>,
                <TT>chandelete</TT>,
                <TT>filtdelete</TT>
        <LI> added
                <TT>trackrename</TT>,
                <TT>chanrename</TT>,
                <TT>filtrename</TT>
        <LI> split <TT>changetnum</TT> into <TT>changetdev</TT> and <TT>changetch</TT>,
	     added <TT>chanset</TT>
        <LI> added "event ranges", and an event range argument to
                <TT>trackblank</TT> and
                <TT>trackcopy</TT>
        <LI> removed support for single number channels.
        <LI> added <TT>tracksetmute</TT> and <TT>trackgetmute</TT>
        <LI> added support for system exclusive messages; added
                <TT>sysexlist</TT>,
                <TT>sysexnew</TT>,
                <TT>sysexdelete</TT>,
                <TT>sysexrename</TT>,
                <TT>sysexexists</TT>,
                <TT>sysexinfo</TT>,
                <TT>sysexclear</TT>,
                <TT>sysexsetunit</TT>,
                <TT>sysexadd</TT>,
                <TT>songgetcursysex</TT> and
                <TT>songsetcursysex</TT>.
        <LI> removed <TT>tracksave</TT> and <TT>trackload</TT>
        <LI> removed support for gnu readline(3) library from midish,
                and created the <TT>rmidish</TT> utility, a front-end
                to midish using the readline(3) library.
        <LI> added filters the ability to limit MIDI traffic
                (one controller, one bender, one aftertouch per tick)
        <LI> make the filter drop duplicate controllers, pitch bends and
                aftertouches
        <LI> added global and per filter current channel:
                <TT>songgetcurchan</TT>,
                <TT>songsetcurchan</TT>,
                <TT>filtgetcurchan</TT> and
                <TT>filtsetcurchan</TT>.
	<LI> added global and per channel current input:
                <TT>songgetcurinput</TT>,
                <TT>songsetcurinput</TT>,
                <TT>changetcurinput</TT> and
                <TT>chansetcurinput</TT>.
        <LI> added <TT>trackchanlist</TT> and improved <TT>songinfo</TT>
	<LI> added a MIDI file player and recorder: smfplay(1) and smfrec(1)
        </UL>

<A name="changes_03"></A><H2>13.2 Changes from release 0.2 to release 0.3</H2>

        <UL>
        <LI>added <TT>tracktransp</TT> to transpose tracks
        <LI>added <TT>trackmerge</TT> to merge two tracks
	<LI>make rmidish run midish from the same directory where
	     rmidish is located.
	<LI>now multiple bender events are gathered together. So track editing
	     functions (<TT>trackcopy</TT> &amp; friends) always leave the
	     bender in a neutral state.
	<LI>improved <TT>trackcheck</TT>
	<LI>added <TT>exit</TT> keyword to exit midish
	<LI>Added a <TT>mode</TT> argument to <TT>devattach</TT> function.
	     Now devices can be used in read-only or write-only mode (allowing
	     to use named pipes as MIDI devices).
	<LI>added basic support for the MIDI "Active Sensing" feature
	<LI>make metronome click audible with non-percussive patches
	<LI>save metronome settings
        <LI>added tempo factor: <TT>songsetfactor</TT> and <TT>songgetfactor</TT>
	<LI>changed all track functions to gracefully handle nested notes, overlapping
	     controllers/benders.
	<LI>when entering real-time mode, midish restores states of all
	     controllers/benders corresponding to the current position
	<LI>when leaving real-time mode midish release only notes that
	     are sounding and reset only controllers that are touched
	     instead of resetting all notes/controllers. This allows
	     midish to better share MIDI devices with other sequencers.
	<LI>added support for 14bit controllers
	<LI>added support for RPN/NRPN MIDI events.
	<LI>split format 0 MIDI files into 16 tracks (one per MIDI channel)
	<LI>made controller interpretation in editing functions configurable:
		<TT>ctlconf</TT>, <TT>ctlconfx</TT>,
		<TT>ctlunconf</TT> and <TT>ctlinfo</TT>.
	<LI>added per-device controller precision selection (7bit or 14bit):
		<TT>devixctl</TT> and <TT>devoxctl</TT>.
	<li>added <tt>chanunconfev</tt> function to remove an event from a channel
	</UL>

<A name="changes_04"></A><H2>13.3 Changes from release 0.3 to release 0.4</H2>

        <UL>
        <LI>added <TT>songgetsign</TT> and <tt>songgettempo</tt>
	    functions returning time signature and tempo respectively
	    at any measure number
	<li>added output MIDI merger, to avoid conflicts
	    between tracks and MIDI input
	<li>continuous controllers are merged more
	    intelligently in performance mode, avoiding clipping
	</ul>

<A name="attributes"></A><H1>14 Project attributes</H1>

<A name="section_14_1"></A><H2>14.1 Device attributes</H2>

	The following table summarizes the device attributes:

	<P align="center">
	<TABLE border="1">
	<TR>
	<TH>attribute
	<TH>description
	<TR>
	<TD>unit number
	<TD>integer that is used to reference the device
	<TR>
	<TD>tickrate
	<TD>number of tick per unit note, default is 96, which corresponds
		to the MIDI standard
	<TR>
	<TD>sendrt flag
	<TD>boolean; if sendrt = true, the real-time events
		(like start, stop, ticks) are transmitted to the MIDI device.
	<TR>
	<TD>ixctlset
	<TD>list of continuous controllers that are expected to be
		received with 14bit precision.
	<TR>
	<TD>oxctlset
	<TD>list of continuous controllers that will be transmitted
		with 14bit precision
	</TABLE>


<A name="section_14_2"></A><H2>14.2 Channel attributes</H2>

	The following table summarizes the channel attributes:

	<P align="center">
	<TABLE border="1">
	<TR>
	<TH>attribute
	<TH>description
	<TR>
	<TD>name
	<TD>identifier used to reference the channel
	<TR>
	<TD>{dev&nbsp;chan}
	<TD>device and MIDI channel to which MIDI events are sent
	<TR>
	<TD>conf
	<TD>events that are sent when performance mode is entered
	<TR>
	<TD>curinput
	<TD>default input <TT>{dev&nbsp;chan}</TT> pair.
		This value isn't used in
		real-time, however it can be used as default
		value when adding new rules to a filter
		that uses this channel.
	</TABLE>

<A name="section_14_3"></A><H2>14.3 Filter attributes</H2>

	The following table summarizes the filter attributes:

	<P align="center">
	<TABLE border="1">
	<TR>
	<TH>attribute
	<TH>description
	<TR>
	<TD>name
	<TD>identifier used to reference the filter
	<TR>
	<TD>rules set
	<TD>set of rules that handle MIDI events
	<TR>
	<TD>current channel
	<TD>default channel. This value isn't used in real-time,
		however it can be used as default value when
		adding new rules to the filter.
	</TABLE>


<A name="section_14_4"></A><H2>14.4 Track attributes</H2>

	The following table summarizes the track attributes:

	<P align="center">
	<TABLE border="1">
	<TR>
	<TH>attribute
	<TH>description
	<TR>
	<TD>name
	<TD>identifier used to reference the track
	<TR>
	<TD>mute flag
	<TD>if true then the track is not played on by songplay/songrecord
	<TR>
	<TD>current filter
	<TD>default filter. The track is recorded
		with this filter. If there is no current filter,
		then is is recorded with the song's default filter.
	</TABLE>


<A name="section_14_5"></A><H2>14.5 Sysex attributes</H2>

	The following table summarizes the sysex back attributes:

	<P align="center">
	<TABLE border="1">
	<TR>
	<TH>attribute
	<TH>description
	<TR>
	<TD>name
	<TD>identifier used to reference the sysex back
	<TR>
	<TD>list of messages
	<TD>each message in the list contains
		the actual message and the unit number of the device
		to which the message has to be sent.
	</TABLE>

<A name="section_14_6"></A><H2>14.6 Song attributes</H2>

	The following table summarizes the song attributes:

	<P align="center">
	<TABLE border="1">
	<TR>
	<TH>attribute
	<TH>description
	<TR>
	<TD>meta track
	<TD>a track containing tempo changes and time signature changes
	<TR>
	<TD>ticks_per_unit
	<TD>number of MIDI ticks per unit note, the default value is 96
		 which corresponds to the MIDI standard.
	<TR>
	<TD>tempo_factor
	<TD>number by which the tempo is multiplied
	    on play and record.
	<TR>
	<TD>metronome flag
	<TD>if the metronome = true, then the metronome is audible
	<TR>
	<TD>metro_hi
	<TD>a note-on event that is sent on the beginning of every measure
		if the metronome is enabled
	<TR>
	<TD>metro_lo
	<TD>a note-on event that is sent on the beginning of every beat
		if the metronome is enabled
	<TR>
	<TD>curtrack
	<TD>default track: the track that will be recorded in record mode
	<TR>
	<TD>curfilt
	<TD>default filter. The filter with which the
		default track is recorded if it hasn't its
		default filter.
	<TR>
	<TD>curchan
	<TD>default channel. This value isn't used in real-time,
		however it can be used as default value when
		adding new rules to the filter.
	<TR>
	<TD>curpos
	<TD>current position (in measures) within the song. Playback
		and record start from this positions. It is also
		user as the beginning of the current selection
	<TR>
	<TD>curlen
	<TD>length (in measures) of the current selection.
		This value isn't used in real-time,
		however it can be used as default value in track
		editing functions.
	<TR>
	<TD>curquant
	<TD>current quantization step in ticks.
		This value isn't used in real-time,
		however it can be used as default value for
		the track editing functions
	<TR>
	<TD>curev
	<TD>current event selection
		This value isn't used in real-time,
		however it can be used as default value for
		the track editing functions
	<TR>
	<TD>curinput
	<TD>default input <tt>{dev&nbsp;chan}</tt> pair.
	        This value isn't used in
		real-time, however it can be uses as default
		value when adding new values to a filter
		that uses this channel.
	</TABLE>

<A name="ev"></A><H1>15 Events and event ranges specification</H1>
<A name="ev_ev"></A><H2>15.1 Event specification</H2>
        <P>
        Some functions take events as arguments. An event
        is specified as a list containing:
        <UL>
        <LI> a reference from the following list:
             <TT>noff</TT>, <TT>non</TT>, <TT>kat</TT>,
             <TT>xctl</TT>, <TT>xpc</TT>, <TT>cat</TT>, <TT>bend</TT>
	     <TT>rpn</TT>, <TT>nrpn</TT>.
        <LI> a channel
        <LI> a number
        <LI> a second number (not for <TT>cat</TT> and <TT>bend</TT>)
        </UL>

        Event references correspond to the following
        MIDI events:
        <P align="center">
        <TABLE border="1">
	<TR>	<TH>ref. name		<TH>MIDI event
        <TR>    <TD><TT>noff</TT>       <TD>note off
        <TR>    <TD><TT>non</TT>        <TD>note off
        <TR>    <TD><TT>kat</TT>        <TD>key after-touch (poly)
        <TR>    <TD><TT>ctl</TT>        <TD>7bit controller
        <TR>    <TD><TT>xctl</TT>       <TD>14bit controller
        <TR>    <TD><TT>xpc</TT>        <TD>bank and program change
        <TR>    <TD><TT>cat</TT>        <TD>channel after-touch (mono)
        <TR>    <TD><TT>bend</TT>       <TD>pitch bend
	<TR>	<TD><TT>rpn</TT>	<TD>RPN change
	<TR>	<TD><TT>nrpn</TT>	<TD>NRPN change
        </TABLE>

        <P align="left">
        Examples:
        <BR>
        note-on event on device 2, channel 9, note 64 with velocity 100:

        <PRE>
        {non {2 9} 64 100}
        </PRE>

        program change device 1, channel 3, patch 34, bank 1234

        <PRE>
        {xpc {1 3} 34 1234}
        </PRE>

        set controller number 7 to 99
        on device/channel drums:

        <PRE>
        {ctl drums 7 99}
        </PRE>

<A name="ev_evspec"></A><H2>15.2 Event ranges specification</H2>

        Some track editing functions take an event range as argument.
        The event range is specified as a list containing:
        <UL>
        <LI> an optional reference from the following list:
             <TT>any</TT>, <TT>note</TT>, <TT>ctl</TT>, <TT>pc</TT>,
	     <TT>cat</TT>, <TT>bend</TT>, <TT>rpn</TT>, <TT>nrpn</TT>
	     <TT>xpc</TT>, <TT>xctl</TT>.

        <LI> an optional channel range specified as a list containing
                a device number range and a MIDI channel number
                range. Number ranges are specified as two-number list
                like this <TT>{12 34}</TT>. Channel name matches an unique channel.
        <LI> an optional  number range, specified as a list
                of two number like this <TT>{12 65}</TT>
        <LI> an optional second number range, in the same
                format as the first one (not permitted for <TT>pc</TT>,
                <TT>bend</TT> and <TT>cat</TT>)
        </UL>
        In the above, empty lists can also be used. An empty list
        means "match everything".

        <P>
        Examples:
        <BR>
        <PRE>
        {}                      # match everything
        { any }                 # match everything
        { any bass }            # match anything on channel "bass"
        { any {1 4} }           # match anything on device 1, channel 4
        { any {1 {}} }          # match anything on device 1, any channel
        { any {{} 9} }          # match anything on any device and channel 9
        { note }                # match note events
        { note {1 9} }          # match notes on dev 1, channel 9
        { note {0 {}} }         # match notes on device 0
        { note {0 {3 5}} }      # match notes on device 0, channel 3, 4, 5
        { note {} {0 64} }      # match notes between 0 an 64
        { ctl bass }            # match controllers on channel "bass"
        { ctl bass 7 }          # match controller 7 on channel "bass"
        { bend {} }             # match bender
        { xctl {} 19 }          # match 14bit controller number 19
        { xpc  {} 21 1234 }     # match patch 21 on bank 1234
        { nrpn {} 21 }          # NRPN 21 change
        </PRE>


<A name="language"></A><H1>16 Language reference</H1>
<A name="section_16_1"></A><H2>16.1 Lexical structure</H2>

        The input line is split into tokens:

        <UL>
        <LI> Identifiers:
                <BR>
                an identifier is a sequence of up to 32
                characters, digits and underscores ("<TT>_</TT>").
                However, an identifier cannot start with a
                digit. Examples:
        <PRE>
        mytrack _mytrack  my34_track23          # good
        123mytrack                              # bad, starts with digit
        mytrackabcdefghijklmnopqrstuvwxyz       # bad, to long
        </PRE>

        <LI> Numbers
                <BR>
                numbers should be in decimal or hex format and may
                not exceed 2^31. Hex numbers are preceded
                by "0x", as in the C language. Examples:

                <P align="center">
                <TABLE border="1">
		<TR>	<TH>token		<TH>value
                <TR>    <TD><TT>123</TT>        <TD>123 in decimal
                <TR>    <TD><TT>0x100</TT>      <TD>256 in hex
                <TR>    <TD><TT>0xF0</TT>       <TD>240 in hex
                </TABLE>

        <LI> String constants
                <BR>
                string constants are sequence of printable
                characters enclosed in pairs of double quotes.
                Thus a string cannot contain double quotes,
                tabs, newlines.

        <LI> Keywords
                <BR>
                valid keywords are: <TT>nil</TT>, <TT>let</TT>,
                <TT>if</TT>, <TT>else</TT>, <TT>for</TT>, <TT>in</TT>
		<TT>return</TT>, <TT>exit</TT> and <TT>proc</TT>.

        <LI> Operators, separators etc...
                <BR>
                sequences of meta-characters like "<TT>(</TT>", "<TT>)</TT>",
                "<TT>+</TT>", "<TT>$</TT>", newline character,
                "<TT>;</TT>",  etc...

        <LI> Comments
                <BR>
                comments are ignored, they start with "<TT>#</TT>"
                and end with the new line
                character.

        </UL>

        Multiple lines ending with "<TT>\</TT>" are parsed as a
        single line. Anything else generates a "bad token" error.


<A name="section_16_2"></A><H2>16.2 Statements</H2>

        <P>
        Any input line can be ether a function definition or a
        statement.

        Most statements end with the "<TT>;</TT>"
        character.  However, in order to improve
        interactivity, the newline character can be used
        instead. Thus, the newline character cannot be
        used as a space.

        A statement can be:

        <UL>
        <LI>
        A procedure call, example:

        <PRE>
        myproc arg1 arg2
        </PRE>


        <LI>
        An assignment using the <TT>let</TT> keyword,
        examples:

        <PRE>
        let x = 123
        let y = 1 + 2 * (3 + x)
        </PRE>

        <P>
        The left-hand side should be the name of
        a variable and the right hand side an
        expression (see the expression section).

        <LI>
        An <TT>if..else</TT> statement, example:

        <PRE>
        if $i {
                print "i is not zero";
        } else {
                print "i is zero";
        }
        </PRE>

        the <TT>else</TT> and the second block are
        not mandatory. Note that since newline
        character is interpreted as a "<TT>;</TT>", the
        line cannot be broken in an arbitrary
        way. If the expression following the <TT>if</TT>
        keyword is true the first block is executed,
        otherwise the second one (if any) is executed. The
        expression is evaluated in the following way:

        <P align="center">
        <TABLE border="1">
	<TR>	<TH>expression		<TH>bool. value
        <TR>    <TD>non-zero integer    <TD>true
        <TR>    <TD>zero integer        <TD>false
        <TR>    <TD>non-empty list      <TD>true
        <TR>    <TD>empty list          <TD>false
        <TR>    <TD>non-empty string    <TD>true
        <TR>    <TD>empty string        <TD>false
        <TR>    <TD>any name            <TD>true
        <TR>    <TD>nil                 <td>false
        </TABLE>

        <LI>
        A loop over a list:

        <PRE>
        for i in {"bli" "bla" "blu"} {
                print $i;
        }
        </PRE>

        the block is executed for each value
        of the list to which "<TT>$i</TT>" is set.

        <LI>
        A return statement. The return statement ends
        the procedure execution and returns a
        value to the caller. Example:

        <PRE>
        return $x * $x;
        </PRE>

	<LI>
	An exit statement. The exit statement ends
	the execution of the current script.
	It takes no arguments. Example:

	<PRE>
	exit
	</PRE>

        </UL>

<A name="section_16_3"></A><H2>16.3 Expressions</H2>

        An expression can be an arithmetic expression of constants,
        expressions, variable values, return values of
        function calls.

        The following constant types are supported:

        <P align="center">
        <TABLE border="1">
	<TR>	<TH>token				<TH> type
        <TR>    <TD><TT>"this is a string"</TT>         <TD> a string
        <TR>    <TD><TT>12345</TT>                      <TD> a number
        <TR>    <TD><TT>mytrack</TT>                    <TD> a reference
        <TR>    <TD><TT>nil</TT>                        <TD> has no value
        </TABLE>

        <P>
        Variable are referenced by their identifier.
        Value of a variable is obtained with the "<TT>$</TT>"
        character.

        <PRE>
        let i = 123             # puts 123 in i
        print $i                # prints the value of i
        </PRE>

        The following operators are recognized:

        <P align="center">
        <TABLE border="1">

        <TR>    <TH>oper.       <TH>usage               <TH>associativity

        <TR>    <TD><TT>{}</TT>
                <TD>list definition
                <TD rowspan="3">left to right

        <TR>    <TD><TT>()</TT>
                <TD>grouping

        <TR>    <TD><TT>[]</TT>
                <TD>function call

        <TR>    <TD><TT>!</TT>
                <TD>logical NOT
                <TD rowspan="3">right to left

        <TR>    <TD><TT>~</TT>
                <TD>bitwise NOT

        <TR>    <TD><TT>-</TT>
                <TD>unary minus

        <TR>    <TD><TT>*</TT>
                <TD>multiplication
                <TD rowspan="3">left to right

        <TR>    <TD><TT>/</TT>
                <TD>division

        <TR>    <TD><TT>%</TT>
                <TD>reminder

        <TR>    <TD><TT>+</TT>
                <TD>addition
                <TD rowspan="2">left to right

        <TR>    <TD><TT>-</TT>
                <TD>subtraction

        <TR>    <TD><TT>&lt;&lt;</TT>
                <TD>left shift
                <TD rowspan="2">left to right

        <TR>    <TD><TT>&gt;&gt;</TT>
                <TD>right shift

        <TR>    <TD><TT>&lt;</TT>
                <TD>less
                <TD rowspan="4">left to right

        <TR>    <TD><TT>&lt;=</TT>
                <TD>less or equal

        <TR>    <TD><TT>&gt;</TT>
                <TD>greater

        <TR>    <TD><TT>&gt;=</TT>
                <TD>greater or equal

        <TR>    <TD><TT>==</TT>
                <TD>equal
                <TD rowspan="2">left to right

        <TR>    <TD><TT>!=</TT>
                <TD>not equal

        <TR>    <TD><TT>&amp;</TT>
                <TD>bitwise AND
                <TD>left to right

        <TR>    <TD><TT>^</TT>
                <TD>bitwise XOR
                <TD>left to right

        <TR>    <TD><TT>|</TT>
                <TD>bitwise OR
                <TD>left to right

        <TR>    <TD><TT>&amp;&amp;</TT>
                <TD>logical AND
                <TD>left to right

        <TR>    <TD><TT>||</TT>
                <TD>logical OR
                <TD>left to right
        </TABLE>

        <P>
        Examples:

        <PRE>
        2 * (3 + 4) + $x
        </PRE>

        is an usual integer arithmetic expression.

        <PRE>
        [tracklen mytrack]
        </PRE>

        is the returned value of the procedure <TT>tracklen</TT>
        called with a single argument <TT>mytrack</TT>.

        <PRE>
        {"bla" 3 zer}
        </PRE>

        is a list containing the string <TT>"bla"</TT> the integer
        3 and the name <TT>zer</TT>. A list is a set of
        expressions separated by spaces and enclosed between
        braces, a more complicated example is:

        <PRE>
        {"hello" 1+2*3 mytrack $i [myproc] {a b c}}
        </PRE>


<A name="section_16_4"></A><H2>16.4 Procedure definition</H2>

        A procedure is defined with the keyword
        <TT>proc</TT> followed by the name of the procedure,
        the names of its arguments and a block containing
        its body, example:

        <PRE>
        proc doubleprint x y {
                print $x
                print $y
        }
        </PRE>

        Arguments and variables defined within a procedure
        are local to that procedure
        and may shadow a global variable with the same
        name. The return value is given to the caller
        with a <TT>return</TT> statement:

        <PRE>
        proc square x {
                return $x * $x
        }
        </PRE>


<A name="functs"></A><H1>17 Function reference</H1>

<A name="func_track"></A>
<A name="section_17_1"></A><H2>17.1 Track functions</H2>

<A name="func_tlist"></A>
<B><TT>tlist</TT></B>
        <BLOCKQUOTE>
        return the list of names of the tracks in the song
        example:
        <PRE>
        print [tlist]
        </PRE>
        </BLOCKQUOTE>

<A name="func_tnew"></A>
<B><TT>tnew trackname</TT></B>
        <BLOCKQUOTE>
        create an empty track named <TT>trackname</TT>
        </BLOCKQUOTE>

<A name="func_tdel"></A>
<B><TT>tdel</TT></B>
        <BLOCKQUOTE>
        delete the current track.
        </BLOCKQUOTE>

<A name="func_tren"></A>
<B><TT>tren newname</TT></B>
        <BLOCKQUOTE>
        change the name of the current track to <TT>newname</TT>
        </BLOCKQUOTE>

<A name="func_texists"></A>
<B><TT>texists trackname</TT></B>
        <BLOCKQUOTE>
        return 1 if <TT>trackname</TT> is a track, 0 otherwise
        </BLOCKQUOTE>

<A name="func_taddev"></A>
<B><TT>taddev measure beat tick ev</TT></B>
        <BLOCKQUOTE>
        put the event <TT>ev</TT> on the current track
        at the position given by <TT>measure</TT>,
        <TT>beat</TT> and <TT>tick</TT>
        </BLOCKQUOTE>

<A name="func_tsetf"></A>
<B><TT>tsetf filtname</TT></B>
        <BLOCKQUOTE>
        set the default filter (for recording) of
        the current track to <TT>filtname</TT>. It will
        be used in performace mode if there is no current filter.
        </BLOCKQUOTE>

<A name="func_tgetf"></A>
<B><TT>tgetf</TT></B>
        <BLOCKQUOTE>
        return the default filter (for recording)
        of the current track, returns <TT>nil</TT> if none
        </BLOCKQUOTE>

<A name="func_tcheck"></A>
<B><TT>tcheck</TT></B>
        <BLOCKQUOTE>
        check the current track for orphaned notes,
        nested notes and other anomalies; also
        removes multiple controllers in the same tick
        </BLOCKQUOTE>

<A name="func_tcut"></A>
<B><TT>tcut amount</TT></B>
        <BLOCKQUOTE>
        cut <TT>amount</TT> measures from the current track
	at the current position.
        </BLOCKQUOTE>

<A name="func_tclr"></A>
<B><TT>tclr</TT></B>
        <BLOCKQUOTE>
        clear the current selection of the current track.
	only events matching the current event selection
	(see <a href="#func_ev">ev</a> function) are
	removed.
        </BLOCKQUOTE>

<A name="func_tins"></A>
<B><TT>tins amount</TT></B>
        <BLOCKQUOTE>
        insert <TT>amount</TT> empty measures in the
        current track, at the current position.
        </BLOCKQUOTE>

<A name="func_tcopy"></A>
<B><TT>tcopy trackname2 where</TT></B>
        <BLOCKQUOTE>
        copy the current selection of the current track
	into track <TT>trackname2</TT>
        at position <TT>where</TT>.
	Only events matching
        the current event selection
	(see <a href="#func_ev">ev</a> function)
	are copied
        </BLOCKQUOTE>

<A name="func_tquant"></A>
<B><TT>tquant rate</TT></B>
        <BLOCKQUOTE>
        quantize the current selection of the current track using
	the current quatization step
	(see <a href="#func_ev">setq</a> function).
	Note positions
	are rounded to the nearest tick multiple of the quatization step;
	Rate must be between 0 and 100: 0 means no
        quantization and 100 means full quantization.
        </BLOCKQUOTE>

<A name="func_ttransp"></A>
<B><TT>ttransp halftones</TT></B>
        <BLOCKQUOTE>
        transpose note events of current selection of the current track,
	by <TT>halftones</TT> half tones.
	Only events matching the current event selection
	(see <a href="#func_ev">ev</a> function)
	are transposed.
        </BLOCKQUOTE>

<A name="func_tmerge"></A>
<B><TT>trackmerge sourcetrack</TT></B>
        <BLOCKQUOTE>
        merge the <tt>sourcetrack</tt> into
	the current track
        </BLOCKQUOTE>

<A name="func_mute"></A>
<B><TT>mute trackname</TT></B>
        <BLOCKQUOTE>
        Mute the given track, ie events from <tt>trackname</tt>
	will not be played during record/playback.
        </BLOCKQUOTE>

<A name="func_unmute"></A>
<B><TT>mute trackname</TT></B>
        <BLOCKQUOTE>
        Unmute the given track, ie events from <tt>trackname</tt>
	will be played during record/playback.
        </BLOCKQUOTE>

<A name="func_getmute"></A>
<B><TT>getmute trackname</TT></B>
        <BLOCKQUOTE>
        Return 1 if the given track is muted and 0 otherwise.
        </BLOCKQUOTE>

<A name="func_tclist"></A>
<B><TT>tclist</TT></B>
        <BLOCKQUOTE>
        Return the list of channels used by events stored in the
	current track.
        </BLOCKQUOTE>

<A name="func_tinfo"></A>
<B><TT>tinfo</TT></B>
        <BLOCKQUOTE>
	scan the current selection of the current track, an for each
        measure display the number of events that match the current
        event selection
	</BLOCKQUOTE>

<A name="func_chan"></A>
<A name="section_17_2"></A><H2>17.2 Channel functions</H2>

<A name="func_cnew"></A>
<B><TT>cnew channelname {dev midichan}</TT></B>
        <BLOCKQUOTE>
        create an new channel named <TT>channelname</TT>
        and assigned the given device and MIDI channel.
        </BLOCKQUOTE>

<A name="func_cset"></A>
<B><TT>cset {dev midichan}</TT></B>
        <BLOCKQUOTE>
        set the device/channel pair of the current channel.
        </BLOCKQUOTE>

<A name="func_chandelete"></A>
<B><TT>cdel</TT></B>
        <BLOCKQUOTE>
        delete current channel.
        </BLOCKQUOTE>

<A name="func_cren"></A>
<B><TT>cren newname</TT></B>
        <BLOCKQUOTE>
        rename the current channel to <TT>newname</TT>
        </BLOCKQUOTE>

<A name="func_chanexists"></A>
<B><TT>cexists channelname</TT></B>
        <BLOCKQUOTE>
        return 1 if <TT>channelname</TT> is a channel, 0 otherwise
        </BLOCKQUOTE>

<A name="func_changetch"></A>
<B><TT>cgetc</TT></B>
        <BLOCKQUOTE>
        return the MIDI channel number of the current channel
        </BLOCKQUOTE>

<A name="func_changetdev"></A>
<B><TT>cgetd channelname</TT></B>
        <BLOCKQUOTE>
        return the device number of the current channel
        </BLOCKQUOTE>

<A name="func_caddev"></A>
<B><TT>caddev event</TT></B>
        <BLOCKQUOTE>
        add the event to the configuration of the current
        channel, typically used set
        the program, volume, depth etc... The channel
        of the event must match the current one.
        </BLOCKQUOTE>

<A name="func_crmev"></A>
<B><TT>crmev evspec</TT></B>
        <BLOCKQUOTE>
	remove all events matching <tt>evspec</tt>
	(see event <A href="#ev_evspec">ranges</A>)
        from the configuration of the current channel
        </BLOCKQUOTE>

<A name="func_cinfo"></A>
<B><TT>cinfo</TT></B>
        <BLOCKQUOTE>
        print all events on the config
        of the current channel.
        </BLOCKQUOTE>

<A name="func_cseti"></A>
<B><TT>cseti {dev chan}</TT></B>
        <BLOCKQUOTE>
        set the default input <TT>{dev chan}</TT> pair
	of the current channel. These values are currently not
	used in realtime, but are are used as default values
	for various filter operations.
        </BLOCKQUOTE>

<A name="func_cgeti"></A>
<B><TT>cgeti</TT></B>
        <BLOCKQUOTE>
        return the default input <TT>{dev chan}</TT> pair
	of the current channel.
        </BLOCKQUOTE>

<A name="func_filt"></A>
<A name="section_17_3"></A><H2>17.3 Filter functions</H2>

<A name="func_fnew"></A>
<B><TT>fnew filtname</TT></B>
        <BLOCKQUOTE>
        create an new filter named <TT>filtname</TT>
        </BLOCKQUOTE>

<A name="func_filtdelete"></A>
<B><TT>fdel filtname</TT></B>
        <BLOCKQUOTE>
        delete the current filter.
        </BLOCKQUOTE>

<A name="func_filtrename"></A>
<B><TT>fren newname</TT></B>
        <BLOCKQUOTE>
        rename the current filter to <TT>newname</TT>
        </BLOCKQUOTE>

<A name="func_fexists"></A>
<B><TT>fexists filtname</TT></B>
        <BLOCKQUOTE>
        return 1 if <TT>filtname</TT> is a filter, 0 otherwise
        </BLOCKQUOTE>

<A name="func_freset"></A>
<B><TT>freset</TT></B>
        <BLOCKQUOTE>
	remove all rules from the current filter.
        </BLOCKQUOTE>

<A name="func_finfo"></A>
<B><TT>finfo</TT></B>
        <BLOCKQUOTE>
        list all fitering rules of the current filter
        </BLOCKQUOTE>

<A name="func_fsetc"></A>
<B><TT>fsetc</TT></B>
        <BLOCKQUOTE>
        set the default channel of the current filter
        to <TT>channame</TT>.
        </BLOCKQUOTE>

<A name="func_fgetc"></A>
<B><TT>fgetc</TT></B>
        <BLOCKQUOTE>
        return the default channel
        of current filter, returns <TT>nil</TT> if none
        </BLOCKQUOTE>

<A name="func_fchgin"></A>
<B><TT>fchgin old_evspec new_evspec</TT></B>
        <BLOCKQUOTE>
        rewrite all filtering rules of the current
	filter to consume ``new_evspec'' events instead of
	``old_evspec'' events.
	This means that each rule that would consume ``old_evspec''
	on the input will start consuming ``new_evspec'' instead.
        </BLOCKQUOTE>

<A name="func_fswapin"></A>
<B><TT>fswapin evspec1 evspec2</TT></B>
        <BLOCKQUOTE>
	Similar to <a href="#func_fchgin">fchgin</a> but swap
	``evspec1'' and ``evspec2'' in the source events 
	set of each rule.
        </BLOCKQUOTE>

<A name="func_fchgout"></A>
<B><TT>fchgout old_evspec new_evspec</TT></B>
        <BLOCKQUOTE>
        rewrite all filtering rules of the current
	filter to produce ``new_evspec'' events instead of
	``old_evspec'' events.
	This means that each rule that would produce ``old_evspec''
	on the output will start producing ``new_evspec'' instead.
        </BLOCKQUOTE>

<A name="func_fswapout"></A>
<B><TT>fswapout evspec1 evspec2</TT></B>
        <BLOCKQUOTE>
	Similar to <a href="#func_fchgout">fchgout</a> but swap
	``evspec1'' and ``evspec2'' in the destination events
	set of each rule.
        </BLOCKQUOTE>

<A name="func_fevmap"></A>
<B><TT>fmap evspec1 evspec2</TT></B>
        <BLOCKQUOTE>
	add a new rule to the current filter, to make it
	convert events matching evspec1 (source) into events matching
	evspec2 (destination).
	Both evspec1 and evspec2 must have the same number of devices,
	channels, notes, controllers etc..
        </BLOCKQUOTE>

<A name="func_funmap"></A>
<B><TT>funmap evspec1 evspec2</TT></B>
        <BLOCKQUOTE>
	remove event maps from the current filter. Any
	mapping with source included in evspec1 and destination
	inluded in evspec2 is deleted.
        </BLOCKQUOTE>

<A name="func_sysex"></A>
<A name="section_17_4"></A><H2>17.4 System exclusive messages functions</H2>

<A name="func_xnew"></A>
<B><TT>xnew sysexname</TT></B>
        <BLOCKQUOTE>
        create a new bank of sysex messages named <TT>sysexname</TT>
        </BLOCKQUOTE>

<A name="func_xdel"></A>
<B><TT>xdel</TT></B>
        <BLOCKQUOTE>
        delete the current bank of sysex messages.
        </BLOCKQUOTE>

<A name="func_xren"></A>
<B><TT>xren newname</TT></B>
        <BLOCKQUOTE>
        rename the current sysex bank to <TT>newname</TT>
        </BLOCKQUOTE>

<A name="func_xexists"></A>
<B><TT>xexists sysexname</TT></B>
        <BLOCKQUOTE>
        return 1 if <TT>sysexname</TT> is a sysex bank, 0 otherwise
        </BLOCKQUOTE>

<A name="func_xrm"></A>
<B><TT>xrm pattern</TT></B>
        <BLOCKQUOTE>
        remove all sysex messages starting with <TT>pattern</TT>
        from the current sysex bank. The given pattern
        is a list of bytes; an empty pattern matches any
        sysex message.
        </BLOCKQUOTE>

<A name="func_xsetd"></A>
<B><TT>xsetd newdev pattern</TT></B>
        <BLOCKQUOTE>
        set device number to <TT>newdev</TT>
        on all sysex messages starting with <TT>pattern</TT>
        in the current sysex bank. The given pattern
        is a list of bytes; an empty pattern matches any
        sysex message.
        </BLOCKQUOTE>

<A name="func_xadd"></A>
<B><TT>xadd devnum data</TT></B>
        <BLOCKQUOTE>
        add to the current sysex bank
        a new sysex message. <TT>data</TT> is a list containing the
        MIDI system exclusive message and <TT>devname</TT> is the device number to which
        the message will be sent when performance mode is entered
        </BLOCKQUOTE>

<A name="func_xinfo"></A>
<B><TT>xinfo</TT></B>
        <BLOCKQUOTE>
        print all sysex messages of the current sysex bank. Messages that are
	too long to be desplayed on a single line are truncated and 
	the ``...'' string is displayed.
        </BLOCKQUOTE>

<A name="func_rt"></A>
<A name="section_17_5"></A><H2>17.5 Real-time functions</H2>

<A name="func_i"></A>
<B><TT>i</TT></B>
        <BLOCKQUOTE>
	enter ``idle'' performance mode. Start
        processing MIDI input and generating MIDI output.
        data passes through the current filter (if any)
        or through the current track's filter (if any).
        </BLOCKQUOTE>

<A name="func_p"></A>
<B><TT>p</TT></B>
        <BLOCKQUOTE>
        play the song from the current position.
        Input passes through the current filter (if any)
        or through the current track's filter (if any).
        </BLOCKQUOTE>

<A name="func_r"></A>
<B><TT>songrecord</TT></B>
        <BLOCKQUOTE>
        play the song and record the input.
        Input passes through the current filter (if any)
        or through the current track's filter (if any). On startup,
	this function play one measure of ``countdown'' before
	the data start being recorded.
        </BLOCKQUOTE>

<A name="func_s"></A>
<B><TT>s</TT></B>
        <BLOCKQUOTE>	
        stop the effect<tt>i</tt>, <tt>p</tt> or <tt>r</tt> functions;
	ie leave performance mode.
        </BLOCKQUOTE>

<A name="func_sendraw"></A>
<B><TT>sendraw device arrayofbytes</TT></B>
        <BLOCKQUOTE>
        send raw MIDI data to device number <TT>device</TT>,
	for debugging purposes only.
        </BLOCKQUOTE>

<A name="func_song"></A>
<A name="section_17_6"></A><H2>17.6 Song functions</H2>

<A name="func_ev"></A>
<B><TT>ev evspec</TT></B>
        <BLOCKQUOTE>
        set the current event selection. Most track editing
	functions will act only on events matching "evspec",
	ignoring all other events.
        </BLOCKQUOTE>

<A name="func_setq"></A>
<B><TT>setq ticks</TT></B>
        <BLOCKQUOTE>
        set the current quatization step to te given number of ticks.
        This value will be used by <a href="func_tquant">tquant</a>
	function and also by all editing functions to optimize
	event selection.
        </BLOCKQUOTE>

<A name="func_getq"></A>
<B><TT>getq</TT></B>
        <BLOCKQUOTE>
        get the current quatization step
        </BLOCKQUOTE>

<A name="func_g"></A>
<B><TT>g measure</TT></B>
        <BLOCKQUOTE>
        set the current song position pointer to
        the given measure number. Record and playback
        will start a that position. This also defines
	the beginning of the current selection used
	by most track editing functions.
        </BLOCKQUOTE>

<A name="func_getpos"></A>
<B><TT>getpos</TT></B>
        <BLOCKQUOTE>
        return the current song position pointer which
	is also the start position of the current selection.
        </BLOCKQUOTE>

<A name="func_sel"></A>
<B><TT>sel length</TT></B>
        <BLOCKQUOTE>
        set the length of the current selection to
	<TT>length</TT> measures. The current selection
	start at the current position set with the 
	``<a href="#func_g">g</a>'' function.
        </BLOCKQUOTE>

<A name="func_getlen"></A>
<B><TT>getlen</TT></B>
        <BLOCKQUOTE>
        return the length (in measures) of the current selection.
        </BLOCKQUOTE>


<A name="func_ct"></A>
<B><TT>ct trackname</TT></B>
        <BLOCKQUOTE>
        set the current track. The current track
	is the one that will be recorded. Most track editing
	functions act on it.
        </BLOCKQUOTE>

<A name="func_gett"></A>
<B><TT>gett</TT></B>
        <BLOCKQUOTE>
        return the current track (if any) or <TT>nil</TT>
        </BLOCKQUOTE>

<A name="func_cf"></A>
<B><TT>cf filtname</TT></B>
        <BLOCKQUOTE>
        set the current filter ot ``filtname''.
	The current filter
	is the one used to process
	input MIDI events in performance mode.
	It's also the one affected
	by all filter editing functions. 
        </BLOCKQUOTE>

<A name="func_getf"></A>
<B><TT>getf</TT></B>
        <BLOCKQUOTE>
        return the current filter
        or <TT>nil</TT> if none
        </BLOCKQUOTE>

<A name="func_cx"></A>
<B><TT>cx sysexname</TT></B>
        <BLOCKQUOTE>
        set the current sysex bank,
        ie the one that will be recorded. The current
	sysex back is the one affected by all sysex
	editing functions.
        </BLOCKQUOTE>

<A name="func_getx"></A>
<B><TT>getx</TT></B>
        <BLOCKQUOTE>
        return the current sysex bank
        or <TT>nil</TT> if none
        </BLOCKQUOTE>

<A name="func_cc"></A>
<B><TT>cc channame</TT></B>
        <BLOCKQUOTE>
        set the current (named) channel. All channel
	editing functions will act on it. It will also
	be used as default value when creating filters.
        </BLOCKQUOTE>

<A name="func_getc"></A>
<B><TT>getc</TT></B>
        <BLOCKQUOTE>
        return the name of the current channel
        or <TT>nil</TT> if none
        </BLOCKQUOTE>

<A name="func_ci"></A>
<B><TT>ci {dev chan}</TT></B>
        <BLOCKQUOTE>
        set the (global) default input <TT>{dev chan}</TT> pair.
	These values will be used ass default values when creating
	channels.
        </BLOCKQUOTE>

<A name="func_geti"></A>
<B><TT>geti</TT></B>
        <BLOCKQUOTE>
        return the (global) default input <TT>{dev chan}</TT> pair.
        </BLOCKQUOTE>

<A name="func_setunit"></A>
<B><TT>setunit ticks_per_unit</TT></B>
        <BLOCKQUOTE>
        set the time resolution of the sequencer to <TT>tpu</TT>
        ticks per unit note (1 unit note = 4 quarter notes). 
        The default is 96 ticks per unit, which is the
        default of the MIDI standard.
        </BLOCKQUOTE>

<A name="func_getunit"></A>
<B><TT>getunit</TT></B>
        <BLOCKQUOTE>
        return the number of ticks per unit note
        </BLOCKQUOTE>

<A name="func_fac"></A>
<B><TT>fac tempo_factor</TT></B>
        <BLOCKQUOTE>
	set the tempo factor for play and record to the given
	integer value. The tempo factor must be between 50 (play
	half of the real tempo) and 200 (play at twice the real
	tempo).
        </BLOCKQUOTE>

<A name="func_getfac"></A>
<B><TT>getfac</TT></B>
        <BLOCKQUOTE>
        return the current tempo factor
        </BLOCKQUOTE>

<A name="func_t"></A>
<B><TT>t beats_per_minute</TT></B>
        <BLOCKQUOTE>
        set the tempo at the current song position
        </BLOCKQUOTE>

<A name="func_mins"></A>
<B><TT>mins amount numerator denominator</TT></B>
        <BLOCKQUOTE>
        insert <TT>amount</TT> blank measures at the
	current song position.
	The time signature used is given
        by numerator/denominator.
	This function only affects the time structure
	of the song, it does not affect any track
        </BLOCKQUOTE>

<A name="func_mdel"></A>
<B><TT>mdel amount</TT></B>
        <BLOCKQUOTE>
        delete <TT>amount</TT> measures starting at
        the current song position.
	This function only affects the time structure
	of the song, it does not affect any track
        </BLOCKQUOTE>

<A name="func_minfo"></A>
<B><TT>minfo</TT></B>
        <BLOCKQUOTE>
        print the meta-track (tempo changes, time signature
        changes.
        </BLOCKQUOTE>

<A name="func_mtempo"></A>
<B><TT>mtempo</TT></B>
        <BLOCKQUOTE>
	Return the tempo at the current song position. The unit
	is beats per minute.
        </BLOCKQUOTE>

<A name="func_msig"></A>
<B><TT>msig</TT></B>
        <BLOCKQUOTE>
	Return the time signature at the current song position. The result
	is a two number list: numerator and denominator.
        </BLOCKQUOTE>

<A name="func_ls"></A>
<B><TT>ls</TT></B>
        <BLOCKQUOTE>
	list all tracks, channels, filters and
	varous default values
        </BLOCKQUOTE>

<A name="func_save"></A>
<B><TT>save filename</TT></B>
        <BLOCKQUOTE>
        save the song into the given file. The ``filename''
        is a quoted string.
        </BLOCKQUOTE>

<A name="func_load"></A>
<B><TT>filename</TT></B>
        <BLOCKQUOTE>
        load the song from a file named <TT>filename</TT>.
        the current song is destroyed, even if
        the load command fails.
        </BLOCKQUOTE>

<A name="func_reset"></A>
<B><TT>reset</TT></B>
        <BLOCKQUOTE>
        destroy completely the song, useful to
        start a new song without restarting the
        program
        </BLOCKQUOTE>

<A name="func_export"></A>
<B><TT>export filename</TT></B>
        <BLOCKQUOTE>
        save the song into a standard MIDI file, <TT>filename</TT>
        is a quoted string.
        </BLOCKQUOTE>

<A name="func_import"></A>
<B><TT>import filename</TT></B>
        <BLOCKQUOTE>
        load the song from a standard MIDI file, <TT>filename</TT>
        is a quoted string. Only MIDI file ``type 1'' and
	``type 0'' are supported.
        </BLOCKQUOTE>

<A name="func_dev"></A>
<A name="section_17_7"></A><H2>17.7 Device functions</H2>

<A name="func_dlist"></A>
<B><TT>dlist</TT></B>
        <BLOCKQUOTE>
        return the list of attached devices
        (list of numbers)
        </BLOCKQUOTE>

<A name="func_dnew"></A>
<B><TT>dnew devnum filename mode</TT></B>
        <BLOCKQUOTE>
        attach MIDI device <TT>filename</TT> as
        device number <TT>devnum</TT>; <TT>filename</TT>
        is a quoted string. The <TT>mode</TT> argument
	is the name of the mode, it can be on if the following:
		<UL>
		<LI> <TT>ro</TT> - read-only, for input only devices
		<LI> <TT>wo</TT> - write-only, for output only devices
		<LI> <TT>rw</TT> - read and write.
		</UL>
        </BLOCKQUOTE>

<A name="func_ddel"></A>
<B><TT>ddel devnum</TT></B>
        <BLOCKQUOTE>
        detach device number <TT>devnum</TT>
        </BLOCKQUOTE>

<A name="func_dclktx"></A>
<B><TT>dclktx { devnum1 devnum2 ... }</TT></B>
        <BLOCKQUOTE>
        Configure the given devices to transmit MIDI clock information
	(MIDI ticks, MIDI start and MIDI stop events). Useful
	to synchronize an external sequencer to midish.
        </BLOCKQUOTE>

<A name="func_dclkrx"></A>
<B><TT>dclkrx devnum</TT></B>
        <BLOCKQUOTE>
        set device number <TT>devnum</TT> to be the master MIDI clock source.
        It will give midish MIDI ticks, MIDI start and MIDI stop events. This
	useful to synchrotize midish to an external sequencer.
	If <TT>devnum</TT> is
        <TT>nil</TT>, then the internal clock will be used and midish
        will act as master device.
        </BLOCKQUOTE>

<A name="func_dclkrate"></A>
<B><TT>dclkrate devnum ticrate</TT></B>
        <BLOCKQUOTE>
        set the number of ticks per unit note that are transmitted
        to the MIDI device (if <a href="func_dclktx">dclktx</a> was called
	for it). Default value is 96 ticks. This is the standard MIDI value and
        its not recommended to change it.
        </BLOCKQUOTE>

<A name="func_dinfo"></A>
<B><TT>dinfo devnum</TT></B>
        <BLOCKQUOTE>
        Print some information about the MIDI device.
        </BLOCKQUOTE>

<A name="func_dixctl"></A>
<B><TT>dixctl devnum list</TT></B>
        <BLOCKQUOTE>
        Setup the list of controllers that are expected to
	be received as 14bit numbers (ie both coarse and fine
	MIDI controller messages will be expected). By default
	only coarse values are used, if unsure
	let this list empty.
        </BLOCKQUOTE>

<A name="func_doxctl"></A>
<B><TT>devoxctl devnum list</TT></B>
        <BLOCKQUOTE>
        Setup the list of controllers that will be transmitted
	as 14bit numbers (both coarse and fine MIDI controller messages).
        </BLOCKQUOTE>

<A name="func_misc"></A>
<A name="section_17_8"></A><H2>17.8 Controller functions</H2>

<A name="func_ctlconf"></A>
<B><TT>ctlconf ctlname ctlnumber defval</TT></B>
        <BLOCKQUOTE>
	Configure controller number <TT>ctlnumber</TT> with name
	<TT>ctlname</TT>, and default value <TT>defval</TT>.
	If defval is <TT>nil</TT>
	then there is no default value and corresponding
	controller events are not grouped into frames.
	See sec. <A href="ctl_frames">Controller frames</A>.
        </BLOCKQUOTE>

<A name="func_ctlconfx"></A>
<B><TT>ctlconfx ctlname ctlnumber defval</TT></B>
        <BLOCKQUOTE>
	Same as <A href="func_ctlconfx">ctlconf</A> function,
	but for 14bit controllers. Thus defval is in the
	range 0..16383.
        </BLOCKQUOTE>

<A name="func_ctlunconf"></A>
<B><TT>ctlconf ctlname</TT></B>
        <BLOCKQUOTE>
	Unconfigure the given controller. <TT>ctlname</TT> is
	the identifier that was used with
	<A href="#func_ctlconf">ctlconf</A>
        </BLOCKQUOTE>


<A name="func_ctlinfo"></A>
<B><TT>ctlinfo</TT></B>
        <BLOCKQUOTE>
        Print the list of configured controllers
        </BLOCKQUOTE>


<A name="func_misc"></A>
<A name="section_17_9"></A><H2>17.9 Misc. functions</H2>

<A name="func_m"></A>
<B><TT>m mode</TT></B>
        <BLOCKQUOTE>
	Set the mode of the metronome. The following modes
	are available:
	<UL>
	<LI> <TT>on</TT> - turned on for both playback and record
	<LI> <TT>rec</TT> - turned on for record only
	<LI> <TT>off</TT> - turned off
	</UL>
        </BLOCKQUOTE>

<A name="func_metrocf"></A>
<B><TT>metrocf eventhi eventlo</TT></B>
        <BLOCKQUOTE>
        select the notes that the metronome plays. The
        pair of events must be note-ons
        </BLOCKQUOTE>

<A name="func_info"></A>
<B><TT>info</TT></B>
        <BLOCKQUOTE>
        display the list of built-in and user-defined
        procedures and global variables
        </BLOCKQUOTE>

<A name="func_print"></A>
<B><TT>print expression</TT></B>
        <BLOCKQUOTE>
        display the value of the expression
        </BLOCKQUOTE>

<A name="func_err"></A>
<B><TT>err string</TT></B>
        <BLOCKQUOTE>
        display the given string and abort the
	statement being executed.
        </BLOCKQUOTE>

<A name="func_exec"></A>
<B><TT>exec filename</TT></B>
        <BLOCKQUOTE>
        read and executes the script from a file, <TT>filename</TT>
        is a quoted string. The execution of the script is aborted
	on error. If the script executes an exit statement, only
	the script is terminated.
        </BLOCKQUOTE>

<A name="func_debug"></A>
<B><TT>debug flag val</TT></B>
        <BLOCKQUOTE>
        set debug-flag <TT>flag</TT> to (integer) value <TT>val</TT>.
        If <TT>val=0</TT> the corresponding debug-info are
        turned off. <TT>flag</TT> can be:
        <UL>
        <LI><TT>rmidi</TT> - show raw MIDI traffic on stderr
        <LI><TT>filt</TT> - show events passing through the current filter
        <LI><TT>song</TT> - show start/stop events
        </UL>
        </BLOCKQUOTE>

<A name="func_panic"></A>
<B><TT>panic</TT></B>
        <BLOCKQUOTE>
        cause the sequencer to core-dump
	</BLOCKQUOTE>

<A name="func_proclist"</A>
<B><TT>proclist</TT></B>
	<BLOCKQUOTE>
	Return the list of all user defined procs.
	</BLOCKQUOTE>

<A name="func_builtinlist"</A>
<B><TT>builtinlist</TT></B>
	<BLOCKQUOTE>
	Return a list of all builtin commands.
	</BLOCKQUOTE>

<A name="section_18"></A><h1>18 Using midish in other programs</h1>

	<p>
	A program that wants to use a midish feature, may start midish
	and issue commands on its standard input. Then, the standard
	output of midish could be parsed so the program can obtain the
	desired information (if any).

	<p>
	To ease this process, the midish binary can be
	started with the <b>-v</b> flag; in this case it will write
	additionnal information on its standard output, allowing the
	caller to be notified of changes of the state of midish. The
	information is written on a single line starting with the
	<b>+</b> sign, as follows:

	<ul>
	<li><b>+ready</b><br> means that midish is ready to
	parse and execute a new line. A front-end should
	always wait for this string before issuing any command.

	<li><b>+pos measure beat tick</b><br> is written
	during performace mode on every beat, it gives the current
	song position.
	</ul>

	<p>
	No midish function (like <a href="#func_print">print</a>) can
	generate a line starting with the <b>+</b> sign, so it is safe
	to assume that such lines are synchronization lines and not
	the output of a function.  Furthermore, such lines will never
	appear in the middle of the output of a function.  Additionnal
	information may be available in the same format in future
	versions of midish; thus front-ends should be able to ignore
	unknown lines starting with <b>+</b>.

	<p>
	Generally, any front-end should use a loop similar
	to the following:

	<pre>
	while (!eof) {
		command = get_command_from_user();
		wait_for("+ready");
		write_to_midish_stdin(command);
		result = parse_midish_stdout();
		do_something(result);
	}
	</pre>

<A name="midishrc"></A><H1>19 Sample midishrc-file</H1>

        <P>
        The sample midishrc file shipped in the source tar-balls
        contains a lot of examples of procedure definitions.

        <P>
	<B><TT>ni instrname {device channel}</TT></B>
                <BLOCKQUOTE>
		create a new channel and a new filter
		with the same name in such
		a way that the current input is routed
		to this channel.
                </BLOCKQUOTE>

        <B><TT>ctldrop ictl</TT></B>
                <BLOCKQUOTE>
                make the current filter drop controller number <TT>ictl</TT>
		on the current input
                </BLOCKQUOTE>

        <B><TT>ctlmap ictl octl</TT></B>
                <BLOCKQUOTE>
                make the current filter route controller number
                <TT>ictl</TT> on the current input
		to controller <TT>octl</TT> on the current channel
                </BLOCKQUOTE>

        <B><TT>transpose halftones</TT></B>
                <BLOCKQUOTE>
                make the current filter to transpose
		all notes from the current input and
		to route them to the current channel.
                </BLOCKQUOTE>

        <B><TT>n denominator</TT></B>
                <BLOCKQUOTE>
                set the current note length for quantization
                to <TT>denominator</TT>, 4 means quarter-note,
                8 means eighth-note, 16 means sixteenth-note etc...
		This value will be used by track editing functions.
                </BLOCKQUOTE>

        <B><TT>q rate</TT></B>
                <BLOCKQUOTE>
                quantize the current selection of
                the current track (rate=100 means full quantization
		and rate=0 means no quantization).
                </BLOCKQUOTE>

        <B><TT>cut amount</TT></B>
                <BLOCKQUOTE>
                cut the given number of measures
		from the current position on the current track.
                </BLOCKQUOTE>

        <B><TT>clr</TT></B>
                <BLOCKQUOTE>
                clear (removes events but not blank space)
		the current selection on the current track.
                </BLOCKQUOTE>

        <B><TT>ins num</TT></B>
                <BLOCKQUOTE>
                insert <TT>num</TT> empty measures into the
                current track at the current position
                </BLOCKQUOTE>

        <B><TT>copy pos</TT></B>
                <BLOCKQUOTE>
                copy the current selection <TT>pos</TT> measures
		forward from the current position.
                </BLOCKQUOTE>

        <B><TT>gcut</TT></B>
                <BLOCKQUOTE>
                same as <TT>cut</TT> but acts on all tracks
                simultaneously ("g" like global).
                </BLOCKQUOTE>

        <B><TT>gins num</TT></B>
                <BLOCKQUOTE>
                same as <TT>ins</TT> but acts on all tracks
                simultaneously ("g" like global).
                </BLOCKQUOTE>

        <B><TT>gcopy num</TT></B>
                <BLOCKQUOTE>
                same as <TT>copy</TT> but acts on all tracks
                simultaneously ("g" like global).
                </BLOCKQUOTE>

        <B><TT>solo</TT></B>
                <BLOCKQUOTE>
                mute all tracks but current
                </BLOCKQUOTE>

        <B><TT>nomute</TT></B>
                <BLOCKQUOTE>
                unmute all tracks.
                </BLOCKQUOTE>

        <B><TT>gmon devnum</TT></B>
                <BLOCKQUOTE>
		generate a ``general midi on'' system exclusive message
                for device number <TT>devnum</TT> and store it
		to the current sysex bank.
                </BLOCKQUOTE>

        <B><TT>gmp patch</TT></B>
                <BLOCKQUOTE>
                configures the current channel
                to use general MIDI patch number <TT>patch</TT>.
                (this will send program change event when
                performance mode is entered).
                </BLOCKQUOTE>

        <B><TT>vol value</TT></B>
                <BLOCKQUOTE>
                set volume (controller number 7) of
                the current channel
                </BLOCKQUOTE>

        <B><TT>reverb value</TT></B>
                <BLOCKQUOTE>
                set reverb (controller number 91) of
                the current channel
                </BLOCKQUOTE>

        <B><TT>chorus value</TT></B>
                <BLOCKQUOTE>
                set chorus (controller number 93) of
                the current channel
                </BLOCKQUOTE>

        <B><TT>rpn addr val</TT></B>
                <BLOCKQUOTE>
		set registered parameter number (RPN) <TT>addr</TT>
		for the current channel to <TT>val</TT>. Both <TT>addr</TT>
		and <TT>val</TT> are integers in the range 0..16383.
                </BLOCKQUOTE>

        <B><TT>nrpn addr val</TT></B>
                <BLOCKQUOTE>
		set not registered parameter number (NRPN) <TT>addr</TT>
		for the current channel to <TT>val</TT>. Both <TT>addr</TT>
		and <TT>val</TT> are integers in the range 0..16383.
                </BLOCKQUOTE>


<A name="example"></A><H1>20 Example sessions</H1>

<A name="section_20_1"></A><H2>20.1 Example - MIDI filtering</H2>

        The following session show how to
        configure a keyboard split:

        <PRE>
        1&gt; channew bass {0 5}
        2&gt; chanconfev bass {pc bass 33}
        3&gt; channew piano {0 6}
        4&gt; chanconfev piano {pc piano 2}
        5&gt; filtnew split
        6&gt; filtchanmap split {1 0} bass
        7&gt; filtchanmap split {1 0} piano
        8&gt; filtkeymap  split {1 0} bass   0  63 (-12)
        9&gt; filtkeymap  split {1 0} piano 64 127 0
        10&gt; filtinfo split
        {
                keymap {1 0} {0 2} 65 127 0 id
                keymap {1 0} {0 1} 0 64 116 id
                chanmap {1 0} {0 2}
                chanmap {1 0} {0 1}
        }
        11&gt; songidle
	12&gt; songstop
        13&gt; songsave "piano-bass"
	14&gt;
        </PRE>

        First we define 2 named-channels
        <TT>bass</TT> on device 0, channel 5
        and <TT>piano</TT> on device 0 channel 6.
        Then we assign patches to the respective
        channels. After this, we define a new
        filter <TT>split</TT> and we add
        rules corresponding to the keyboard-split
        on note number 64 (note E3), the bass is
        transposed by -12 half-tones (one octave).

<A name="section_20_2"></A><H2>20.2 Example - recording a track</H2>

        The following session show how to
        record a track. It uses the procedures defined
	in the default <TT>/etc/midishrc</TT>.
        <PRE>
	1&gt; ci {1 0}
	2&gt; ni drums {0 9}
	3&gt; nt dr1
	4&gt; tempo 90
	5&gt; r
	6&gt; s
	7&gt; n 16
	8&gt; sel 32
	9&gt; q 75
	10&gt; p
	11&gt; s
	12&gt; save "myrhythm"
	13&gt;
        </PRE>
        first, we set the default input channel to {1 0}
	(default channel of the keyboard). Then, we
	define the <TT>drum</TT> channel
        on device 0, channel 9 and the corresponding
	filter that will route events from the
	keyboard to the drum channel.  Then we define
        a new track named <TT>dr1</TT> an we start recording.
        Then, we set the quantization step to 16
        (sixteenth note), we select the first 32 measures of
        the track and we quantize them. Finally,
	we start playback and we save the song into a file.


<A name="section_21"></A><H1>21 Thanks</H1>

Many thanks to all who contributed (new features, bug fixes, bug
reports, packaging efforts and other improvements):

Julien Claassen,
Karim Saddem,
Marcell Mars,
Richard L. Hamilton,
Samuel Mimram,
and
Will Woodruff.

<P>
<HR>
<SMALL><EM>
Copyright (c) 2003-2008 Alexandre Ratchov<BR>
Last updated jul 11, 2008
</EM></SMALL>

</BODY>
</HTML>
