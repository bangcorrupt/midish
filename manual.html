<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!--
/*
 * Copyright (c) 2003-2005 Alexandre Ratchov
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met:
 *
 * 	- Redistributions of source code must retain the above
 * 	  copyright notice, this list of conditions and the
 * 	  following disclaimer.
 *
 * 	- Redistributions in binary form must reproduce the above
 * 	  copyright notice, this list of conditions and the
 * 	  following disclaimer in the documentation and/or other
 * 	  materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-->

<HTML>
<HEAD>
<TITLE>midish version 0.2 - user's manual</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</HEAD>
<BODY bgcolor="white" text="black" link="blue" vlink="navy">

<H1>Table of contents</H1>
<P>
<UL>
<LI><A href="#intro">1. Introduction</A>
<LI><A href="#install">2. Installation</A>
<LI><A href="#changes">3. Changes</A>
<LI><A href="#language">4. Language reference</A>
<LI><A href="#devices">5. Devices and channels</A>
<LI><A href="#events">6. Events</A>
<LI><A href="#evrange">7. Event ranges</A>
<LI><A href="#filters">8. Filters</A>
<LI><A href="#tracks">9. Tracks</A>
<LI><A href="#sysex">10. System exclusive message</A>
<LI><A href="#functions">11. Function reference</A>
</UL>


<A name="intro"></A>
<H1>1 Introduction</H1>

	<P>
	Midish is a MIDI sequencing and filtering tool for 
	unix-like operating systems.

	It's is implemented as a sequencing engine and a 
	command-line interpreter.
	
<P>
The sequencing engine is organised as follows:
	<P align="center">
	<BLOCKQUOTE>
	<PRE>
			+--------------+	    
			| track_1 play |---+
			+--------------+   |
					   |
			     ...        ---+
					   |
			+--------------+   |    
			| track_N play |---+
			+--------------+   |
					   |
					   |	+----------+
+---------+		+------------+     +--->|	   |
|	  |	        |	     |		| midi out |
| midi in |-----+------>|   filter   |-----+--->|	   |
|  	  |	|	|	     |	   |	+----------+
+---------+	|	+------------+     |
		|			   |	+----------------+
		|			   +--->| track_X record |
		|	+--------------+	+----------------+
		+------>| sysex record |
			+--------------+
	</PRE>
	</BLOCKQUOTE>
Midi input passes though a filter/router that rewrites the midi stream and
then is sent to the midi output. Optionally (play and record mode)
each track is also sent to the output, and in record mode, the output of the
filter is recorded on the <I>current track</I>.

<P>
On the other hand, the command-line interpreter is used to configure
the sequencing engine: create and manage tracks, define filtering rules
start/stop recording, etc...

<A name="install"></A>
<H1>2 Installation</H1>

<H2>2.1 Requirements</H2>

	Requirements:
	<UL>
	<LI>	a midi sound module 
	<LI>	a midi keyboard
	<LI>	a POSIX unix-like operating system with "raw" midi support.
		Midish works on OpenBSD (its development platform)
		and Linux.
	<LI>	the readline(3) library
	</UL>

Without any midi-devices Midish will be probably useless.

<H2>2.2 Installation</H2>

	<UL>
	<LI> untar and gunzip the tar-ball:

	<PRE>
	gzip -dc midish-0.2.tar.gz | tar xf -
	cd midish-0.2
	</PRE>

	<LI> 
	edit Makefile and change the readline(3) options in Makefile

	<LI> 
	compile midish, just type '<TT>make all</TT>', this will build
	midish and rmidish, the readline(3) front-end to midish.

	<LI>
	install binaries, documentation and examples by
	typing '<TT>make install</TT>'. They are copied as follows:
	<UL>
	<LI> binaries in '<TT>PREFIX/bin</TT>'
	<LI> manual pages in '<TT>PREFIX/man/man1</TT>'
	<LI> html documentation in '<TT>PREFIX/share/doc/midish</TT>'
	<LI> example files in '<TT>PREFIX/share/examples/midish</TT>'
	</UL>
	where '<TT>PREFIX</TT>' is by default '<TT>/usr/local</TT>'.
	To change this, set the '<TT>PREFIX</TT>' variable in
	'<TT>Makefile</TT>', for instance: 

	<PRE>
	make PREFIX=/usr/local install
	</PRE>

	<LI>
	if you don't have a .midishrc, copy the sample file by
	typing '<TT>cp midishrc ~/.midishrc</TT>' in your shell

	<LI>
	read the documentation and edit your <TT>~/.midishrc</TT> in order 
	to choose your default midi device by using the '<TT>devattach</TT>' 
	function (example: '<TT>devattach 0 "/dev/rmidi3"</TT>', see next section)

	</UL>

<H2>2.3 Invocation</H2>
	<P>
	when used interactively, midish doesn't need any arguments, 
	so it's started	by typing:

	<PRE>
	midish
	</PRE>

	in your shell. On startup, it tries to execute the
	'<TT>$HOME/.midishrc</TT>' script. If you
	don't want so, use the '<TT>-b</TT>' flag. This is
	useful when you want to use midish in scripts. If
	you have built the readline(3) front-end, you may want
	use it for interactive sessions instead of '<TT>midish</TT>'
	by typing:

	<PRE>
	rmidish
	</PRE>

	You can specify your midi devices
	by using the '<TT>devattach</TT>' function,  for instance:

	<PRE>
	devattach 0 "/dev/rmidi4"
	devattach 1 "/dev/rmidi3"
	</PRE>

	will attach '<TT>/dev/rmidi4</TT>' and '<TT>/dev/rmidi3</TT>' 
	as devices
	number 0 and 1. You can put those statements in 
	your '<TT>$HOME/.midishrc</TT>'

	<P>
	Once started, the sequencer reads and executes commands
	from stdin and writes results (and user non-fatal errors)
	to stdout. Fatal errors and other debugging information is logged
	to stderr.

	Real-time functions (such as playback, recording) 
	are blocking; they can be resumed  by sending an interrupt signal 
	to midish (control-C on its controlling terminal).

	<P>
	You can try to play the demo song in the source tar-ball

	<PRE>
	songload "sample.sng"
	songplay
	</PRE>
	
	To stop the playback, hit control-C. All blocking
	functions (<TT>songplay</TT>, <TT>songrecord</TT>,
	<TT>songidle</TT>) can be resumed with by sending an
	interrupt signal (SIGINT) to midish. To leave midish, hit
	control-D (witch means "end-of-file").

<A name="changes"></A>
<H1>3 Changes</H1>
<H2>3.1 Changes from release 0.1 to release 0.2</H2>

	<UL>
	<LI> added '<TT>device</TT>' parameter to '<TT>sendraw</TT>'
	<LI> replaced '<TT>filtchangein</TT>' by '<TT>filtswapichan</TT>'
		and added '<TT>filtswapidev</TT>'
	<LI> added new filter rules: 
		<TT>filtdevdrop</TT>, 
		<TT>filtchandrop</TT>,
		<TT>filtctldrop</TT> and 
		<TT>filtkeydrop</TT>.
	<LI> added functions that remove existing rules: 
		<TT>filtnodevdrop</TT>, 
		<TT>filtnodevmap</TT>, 
		<TT>filtnochandrop</TT>,
		<TT>filtnochanmap</TT>,
		<TT>filtnoctldrop</TT>,
		<TT>filtnoctlmap</TT>,
		<TT>filtnokeydrop</TT> and
		<TT>filtnokeymap</TT>.
	<LI> added support for external midi synchronisation,
	     added <TT>devsetmaster</TT>, <TT>devgetmaster</TT>
	     and <TT>devsendrt</TT>
	<LI> added 
		<TT>trackdelete</TT>,
		<TT>chandelete</TT>, 
		<TT>filtdelete</TT>
	<LI> added 
		<TT>trackrename</TT>,
		<TT>chanrename</TT>, 
		<TT>filtrename</TT>
	<LI> renamed <TT>changetnum</TT> into <TT>changetch</TT>
	<LI> added "event ranges", and an event range argument to 
		<TT>trackblank</TT> and
		<TT>trackcopy</TT>
	<LI> removed support for single number channels.
	<LI> added <TT>tracksetmute</TT> and <TT>trackgetmute</TT>
	<LI> added support for system exclusive messages; added
		<TT>sysexlist</TT>,
		<TT>sysexnew</TT>,
		<TT>sysexdelete</TT>,
		<TT>sysexrename</TT>,
		<TT>sysexexists</TT>,
		<TT>sysexinfo</TT>, 
		<TT>sysexclear</TT>, 
		<TT>sysexsetunit</TT>, 
		<TT>sysexadd</TT>, 
		<TT>songgetcursysex</TT> and
		<TT>songsetcursysex</TT>.
	<LI> removed <TT>tracksave</TT> and <TT>trackload</TT>
	<LI> removed support for gnu readline(3) library from midish, 
	 	and created the <TT>rmidish</TT> utility, a front-end
		to midish using the readline(3) library.	
	<LI> added filters the ability to limit midi trafic
		(one controller, one bender, one aftertouch per tic)
		
	<LI> make the filter strip duplicate controlles, pitch bends and
		aftertouches
	<LI> added global and per filter current channel: 
		<TT>songgetcurchan</TT>,
		<TT>songsetcurchan</TT>,
		<TT>filtgetcurchan</TT> and
		<TT>filtsetcurchan</TT>.
	<LI> added <TT>trackchanlist</TT> and impoved <TT>songinfo</TT>	
	</UL>

<A name="language"></A>
<H1>4 Language reference</H1>
<H2>4.1 Lexical structure</H2>

	The input line is split into tokens:

	<UL>
	<LI> Identifiers:
		<BR>
		an identifier is a sequence of up to 32
		characters, digits and underscores ('<TT>_</TT>').
		However, an identifier cannot start with a
		digit. Examples:
	<PRE>
	mytrack _mytrack  my34_track23		# good
	123mytrack 				# bad, starts with digit
	mytrackabcdefghijklmnopqrstuvwxyz	# bad, to long
	</PRE>
	
	<LI> Numbers 
		<BR>
		numbers should be in decimal or hex format and may
		not exceed 2^31. Hex numbers are preceded
		by "0x", as in the C language. Examples:
		
		<P align="center">
		<TABLE border="1">
		<TR>	<TD><TT>123</TT>	<TD>123 in decimal
		<TR>	<TD><TT>0x100</TT>	<TD>256 in hex
		<TR>	<TD><TT>0xF0</TT>	<TD>240 in hex
		</TABLE>
			
	<LI> String constants
		<BR>
		string constants are sequence of printable
		characters enclosed in pairs of double quotes.
		Thus a string cannot contain double quotes, 
		tabs, newlines.

	<LI> Keywords
		<BR>
		valid keywords are: <TT>nil</TT>, <TT>let</TT>, 
		<TT>if</TT>, <TT>else</TT>, <TT>for</TT>, and <TT>proc</TT>.

	<LI> Operators, separators etc...
		<BR>
		sequences of meta-characters like '<TT>(</TT>', '<TT>)</TT>', 
		'<TT>+</TT>', '<TT>$</TT>', newline character, 
		'<TT>;</TT>',  etc... 

	<LI> Comments 
		<BR>
		comments are ignored, they start with '<TT>#</TT>' 
		and end with the new line
		character.

	</UL>

	Multiple lines ending with '<TT>\</TT>' are parsed as a 
	single line. Anything else generates a "bad token" error.


<H2>4.2 Statements</H2>

	<P>
	Any input line can be ether a function definition or a
	statement. 

	Most statements end with the '<TT>;</TT>'
	character.  However, in order to improve
	interactivity, the newline character can be used
	instead. Thus, the newline character cannot be
	used as a space.

	A statement can be:

	<UL>
	<LI>
	A procedure call, example:

	<PRE>
	myproc arg1 arg2
	</PRE>


	<LI>
	An assignment using the <TT>let</TT> keyword,
	examples:

	<PRE>
	let x = 123
	let y = 1 + 2 * (3 + x)
	</PRE>

	<P>
	The left-hand side should be the name of
	a variable and the right hand side an
	expression (see the expression section).


	<LI>
	An <TT>if..else</TT> statement, example:

	<PRE>
	if $i {
		print "i is not zero";
	} else {
		print "i is zero";
	}
	</PRE>

	the <TT>else</TT> and the second block are
	not mandatory. Note that since newline
	character is interpreted as a '<TT>;</TT>', the
	line cannot be broken in an arbitrary
	way. If the expression following the <TT>if</TT>
	keyword is true the first block is executed,
	otherwise the second one (if any) is executed. The
	expression is evaluated in the following way:

	<P align="center">
	<TABLE border="1">
	<TR>	<TD>non-zero integer	<TD>true
	<TR>	<TD>zero integer	<TD>false
	<TR>	<TD>non-empty list	<TD>true
	<TR>	<TD>empty list		<TD>false
	<TR>	<TD>any name		<TD>true
	<TR>	<TD>nil			<td>false
	</TABLE>
	
	<LI>
	A loop over a list:

	<PRE>
	for i in { "bli" "bla" "blu" } {
		print $i;
	}
	</PRE>

	the block is executed for each value
	of the list to which '<TT>$i</TT>' is set.

	<LI>
	A return statement. The return statement ends
	the procedure execution and returns a
	value to the caller. Example:

	<PRE>
	return $x * $x;
	</PRE>

	</UL>


<H2>4.3 Expressions</H2>

	An expression can be an arithmetic expression of constants,
	expressions, variable values, return values of
	function calls. 

	The following constant types are supported:

	<P align="center">
	<TABLE border="1">
	<TR>	<TD><TT>"this is a string"</TT>		<TD> a string
	<TR>	<TD><TT>12345</TT>			<TD> a number
	<TR>	<TD><TT>mytrack</TT>			<TD> a reference
	<TR>	<TD><TT>nil</TT>			<TD> has no value
	</TABLE>

	<P>
	Variable are referenced by their identifier. 
	Value of a variable is obtained with the '<TT>$</TT>'
	character.

	<PRE>
	let i = 123		# puts 123 in 'i'
	print $i		# prints the value of 'i'
	</PRE>

	The following operators are recognised:

	<P align="center">
	<TABLE border="1">

	<TR>	<TH>oper.	<TH>usage		<TH>associativity

	<TR>	<TD><TT>{}</TT>	
		<TD>list definition	
		<TD rowspan="3">left to right

	<TR>	<TD><TT>()</TT>	
		<TD>grouping		

	<TR>	<TD><TT>[]</TT>	
		<TD>function call

	<TR>	<TD><TT>!</TT>	
		<TD>logical NOT 	
		<TD rowspan="3">right to left

	<TR>	<TD><TT>~</TT>	
		<TD>bitwise NOT		

	<TR>	<TD><TT>-</TT>
		<TD>unary minus

	<TR>	<TD><TT>*</TT>
	 	<TD>multiplication
		<TD rowspan="3">left to right

	<TR>	<TD><TT>/</TT>
		<TD>division

	<TR>	<TD><TT>%</TT>
		<TD>reminder

	<TR>	<TD><TT>+</TT>
		<TD>addition
		<TD rowspan="2">left to right

	<TR>	<TD><TT>-</TT>
		<TD>subtraction

	<TR>	<TD><TT>&lt;&lt;</TT>
		<TD>left shift	
		<TD rowspan="2">left to right

	<TR>	<TD><TT>&gt;&gt;</TT>
		<TD>right shift
	
	<TR>	<TD><TT>&lt;</TT>
		<TD>less
		<TD rowspan="4">left to right

	<TR>	<TD><TT>&lt;=</TT>
		<TD>less or equal

	<TR>	<TD><TT>&gt;</TT>
		<TD>greater

	<TR>	<TD><TT>&gt;=</TT>
		<TD>greater or equal

	<TR>	<TD><TT>==</TT>
		<TD>equal
		<TD rowspan="2">left to righ

	<TR>	<TD><TT>!=</TT>
		<TD>not equal

	<TR>	<TD><TT>&amp;</TT>
		<TD>bitwise AND
		<TD>left to right

	<TR>	<TD><TT>^</TT>
		<TD>bitwise XOR
		<TD>left to right

	<TR>	<TD><TT>|</TT>
		<TD>bitwise OR
		<TD>left to right

	<TR>	<TD><TT>&amp;&amp;</TT>
		<TD>logical AND
		<TD>left to right

	<TR>	<TD><TT>||</TT>
		<TD>logical OR
		<TD>left to right
	</TABLE>

	<P>
	Examples:

	<PRE>	
	2 * (3 + 4) + $x
	</PRE>

	is an usual integer arithmetic expression.

	<PRE>
	[tracklen mytrack]
	</PRE>
		
	is the returned value of the procedure <TT>tracklen</TT>
	called with a single argument <TT>mytrack</TT>.

	<PRE>
	{ "bla" 3 zer }
	</PRE>

	is a list containing the string <TT>"bla"</TT> the integer
	3 and the name <TT>zer</TT>. A list is a set of
	expressions separated by spaces and enclosed between
	braces, a more complicated example is:

	<PRE>
	{ "hello" 1+2*3 mytrack $i [myproc] { a b c } }	
	</PRE>


<H2>4.4 Procedure definition</H2>

	A procedure is defined with the keyword
	<TT>proc</TT> followed by the name of the procedure, 
	the names of its arguments and a block containing
	its body, example:

	<PRE>
	proc doubleprint x y { 
		print $x
		print $y
	}
	</PRE>

	Arguments and variables defined whithin a procedure 
	are local to that procedure
	and may shadow a global variable with the same
	name. The return value is given to the caller
	with a <TT>return</TT> statement:

	<PRE>
	proc square x {
		return $x * $x
	}
	</PRE>

<A name="devices"></A>
<H1>5 Devices and channels</H1>

	<P>
	Devices are numbered between 0 and 15. They are
	configured with <TT>devattach</TT> and <TT>devdetach</TT>.
	Example:

	<PRE>
	devattach 0 "/dev/rmidi3"
	</PRE>

	Channels are specified by giving the device number
	and the midi channel number in a list:

	<PRE>
	{ devicenum midichan }
	</PRE>

	For instance, to specify channel 9 on device number 2:

	<PRE>
	{ 2 9 }
	</PRE>
	
	<P>
	Named channels can be specified by their names, for
	instance, after:

	<PRE>
	channew drums { 2 9 }	# define a named channel
	</PRE>
		
	<TT>drums</TT> and <TT>{2 9}</TT> become equivalent. Named channels
	can be also used to hold some configuration events,
	see <TT>channew</TT>, <TT>chanconfev</TT>

<A name="events"></A>
<H1>6 Events</H1>

	<P>
	Some functions take events as arguments. An event
	is specified as a list containing:
	<UL>
	<LI> a reference from the following list:
	     <TT>noff</TT>, <TT>non</TT>, <TT>kat</TT>, 
	     <TT>ctl</TT>, <TT>pc</TT>, <TT>cat</TT>, <TT>bend</TT>.
	<LI> a channel
	<LI> a number 
	<LI> a second number (not for <TT>pc</TT> and <TT>cat</TT>)
	</UL>
		
	Event references correspond to the following
	midi events:
	<P align="center">
	<TABLE border="1">
	<TR>	<TD><TT>noff</TT>	<TD>note off
	<TR>	<TD><TT>non</TT>	<TD>note off
	<TR>	<TD><TT>kat</TT>	<TD>key after-touch (poly)
	<TR>	<TD><TT>ctl</TT>	<TD>controller
	<TR>	<TD><TT>pc</TT>		<TD>program change
	<TR>	<TD><TT>cat</TT>	<TD>channel after-touch (mono)
	<TR>	<TD><TT>bend</TT>	<TD>pitch bend
	</TABLE>

	<P>
	Examples:
	<BR>
	note-on event on device 2, channel 9, note 64 with velocity 100:

	<PRE>
	{ non {2 9} 64 100 }
	</PRE>

	program change device 1, channel 3, patch 34

	<PRE>
	{ pc {1 3} 34 }
	</PRE>

	set controller number 7 to 99
	on device/channel drums:

	<PRE>
	{ ctl drums 7 99 }
	</PRE>


<A name="evrange"></A>
<H1>7 Event ranges</H1>

	Some track editing functions take an event range as argument. 
	The event range is specified as a list containing:
	<UL>
	<LI> an optionnal reference from the following list:
	     <TT>any</TT>, <TT>note</TT>, <TT>ctl</TT>, <TT>pc</TT>, <TT>cat</TT>, <TT>bend</TT>.
	<LI> an optionnal channel range specified as a list containing
		a device number range and a midi-channel number
		range. Number ranges are specified as two-number list
		like this <TT>{12 34}</TT>. Channel name matches an unique channel.
	<LI> an optionnal  number range, specified as a list
		of two number like this <TT>{12 65}</TT>
	<LI> an optionnal second number range, in the same
		format as the first one (not permitted for <TT>pc</TT>, 
		<TT>bend</TT> and <TT>cat</TT>)
	</UL>
	In the above, empty lists can also be used. An empty list
	means "match everything".
	
	<P>
	Examples:
	<BR>
	<PRE>
	{}			# match everything
	{ any }			# match everything
	{ any bass }		# match anything on channel 'bass'
	{ any {1 4} }		# match anything on device 1, channel 4
	{ any {1 {}} }		# match anything on device 1, any channel
	{ any {{} 9} }		# match anything on any device and channel 9
	{ note }		# match note events
	{ note {1 9} }		# match notes on dev 1, channel 9
	{ note {0 {}} }		# match notes on device 0
	{ note {0 {3 5}} }	# match notes on device 0, channel 3, 4, 5
	{ note {} {0 64} }	# match notes between 0 an 64
	{ note {} 60 {80 127} }	# match note 60 with velocity between 80 an 127
	{ ctl bass }		# match controllers on channel 'bass'
	{ ctl bass 7 }		# match controller 7 on channel 'bass'
	{ ctl bass 7 {0 64} }	# match ctl 7 on chan 'bass' with value 0->64
	{ bend {} {0 0x1fff} }	# match "lower" bender
	</PRE>	

<A name="filters"></A>
<H1>8 Filters</H1>

	<P>
	Filters are used to route midi events between channels and 
	devices, to make keyboard splits and controller mappings. 
	For instance to route events on device 0 channel 0 to
	device 1 channel 9:

	<PRE>
	filtnew myfilt
	filtchanmap {0 0} {1 9}
	</PRE>

	to map controller 7 (volume) on channel 0, device 0 to controller
	11 (expression) on channel 9, device 1:

	<PRE>
	filtctlmap {0 0} {1 9} 7 11
	</PRE>


	<P>
	In addition to the above features, filters remove
	inconsistencies from the input midi stream. They also
	limit the amount of midi data in order to prevent
	flooding of output devices.

<A name="tracks"></A>
<H1>9 Tracks</H1>

	<P>
	A track is a set of events ordered in time. They can be
	recorded, edited and quantised. Each track has a name and
	a default filter (used for recording). Tracks are
	not bound to any specific channel/device and can
	be used to record a complete song (not recommended).
	On playback all tracks are played simultaneously.


<A name="sysex"></A>
<H1>10 System exclusive message</H1>

	<P>
	Midi system exclusive messages can be recorded and
	sent back to midi devices. They are typically used
	to download/upload the configuration of a midi device.
	Midish uses named 'sysex' banks to record 
	these messages. On playback all sysex messages
	from all banks are send to their respective devices.

<A name="functs"></A>
<H1>11 Function reference</H1>

<H2>11.1 Track functions</H2>

<A name="func_tracklist"></A>
<B><TT>tracklist</TT></B>
	<BLOCKQUOTE>
	returns the list of names of the tracks in the song
	example:
	<PRE>
	print [tracklist]
	</PRE>
	</BLOCKQUOTE>

<A name="func_tracknew"></A>
<B><TT>tracknew trackname</TT></B>
	<BLOCKQUOTE>
	creates an empty track named <TT>trackname</TT>
	</BLOCKQUOTE>

<A name="func_trackdelete"></A>
<B><TT>trackdelete trackname</TT></B>
	<BLOCKQUOTE>
	delete existing track '<TT>trackname</TT>'.
	Current track cannot be deleted.
	</BLOCKQUOTE>

<A name="func_trackreaname"></A>
<B><TT>trackrename trackname newname</TT></B>
	<BLOCKQUOTE>
	rename track '<TT>trackname</TT>' to '<TT>newname</TT>'
	</BLOCKQUOTE>

<A name="func_trackexists"></A>
<B><TT>trackexists trackname</TT></B>
	<BLOCKQUOTE>
	returns 1 if <TT>trackname</TT> is a track, 0 otherwise
	</BLOCKQUOTE>
	
<A name="func_tracksetcurfilt"></A>
<B><TT>tracksetcurfilt trackname filtname</TT></B>
	<BLOCKQUOTE>
	set the default filter (for recording) of
	<TT>trackname</TT> to <TT>filtname</TT>. It will
	be user if there is no current filter.
	</BLOCKQUOTE>

<A name="func_trackgetcurfilt"></A>
<B><TT>trackgetcurfilt trackname</TT></B>
	<BLOCKQUOTE>
	returns the default filter (for recording) 
	of <TT>trackname</TT>, returns <TT>nil</TT> if none
	</BLOCKQUOTE>
		
<A name="func_trackcheck"></A>
<B><TT>trackcheck trackname</TT></B>
	<BLOCKQUOTE>
	checks the whole track for orphaned notes,
	nested notes and other anomalies; also
	removes multiple controllers in the same tic
	</BLOCKQUOTE>

<A name="func_trackgetlen"></A>
<B><TT>trackgetlen trackname</TT></B>
	<BLOCKQUOTE>
	returns the size in tics of track <TT>trackname</TT>,
	example:
	<PRE>
	let l = [trackgetlen mytrack];
	</PRE>
	</BLOCKQUOTE>

<A name="func_trackcut"></A>
<B><TT>trackcut trackname from amount quantum</TT></B>
	<BLOCKQUOTE>
	cuts <TT>amount</TT> measures of the track <TT>trackname</TT>
	from measure <TT>from</TT>.
	</BLOCKQUOTE>

<A name="func_trackblank"></A>
<B><TT>trackblank trackname from amount quantum evspec</TT></B>
	<BLOCKQUOTE>
	clears <TT>amount</TT> measures of the track <TT>trackname</TT>
	from the measure <TT>from</TT>. Only events matching
	the <TT>evspec</TT> argument are removed (see event
	<A href="#evrange">ranges</A>)
	</BLOCKQUOTE>

<A name="func_trackinsert"></A>
<B><TT>trackinsert trackname from amount</TT></B>
	<BLOCKQUOTE>
	inserts <TT>amount</TT> blank measures in track
	<TT>trackname</TT> just before the measure <TT>from</TT>
	</BLOCKQUOTE>

<A name="func_trackcopy"></A>
<B><TT>trackcopy trackname1 from amount trackname2 where quantum evspec</TT></B>
	<BLOCKQUOTE>
	copies <TT>amount</TT> measures starting at <TT>from</TT>
	from track <TT>trackname1</TT> into <TT>trackname2</TT>
	at position <TT>where</TT>. Only events matching
	the <TT>evspec</TT> argument are copied (see event
	<A href="#evrange">ranges</A>)
	</BLOCKQUOTE>

<A name="func_trackquant"></A>
<B><TT>trackquant trackname from amount rate quantum</TT></B>
	<BLOCKQUOTE>
	quantises <TT>amount</TT> measures of the track
	<TT>trackname</TT> from measure <TT>from</TT> ; the quantum is
	the round in tics (see songsetsign). Rate must be
	between 0 and 100. 0 means no quantisation and
	100 means full quantisation.
	</BLOCKQUOTE>

<A name="func_trackaddev"></A>
<B><TT>trackaddev trackname measure beat tic ev</TT></B>
	<BLOCKQUOTE>
	puts the event <TT>ev</TT> on track <TT>trackname</TT>
	at the position given by <TT>measure</TT>,
	<TT>beat</TT> and <TT>tic</TT>
	</BLOCKQUOTE>

<A name="func_tracksetmute"></A>
<B><TT>tracksetmute trackname muteflag</TT></B>
	<BLOCKQUOTE>
	If <TT>muteflag</TT> is equal to 1 the the track
	is mutted ie it will not be played during record/playback.
	If <TT>muteflag</TT> is equal to 0 the the track
	is no more mutted ie it will be played during record/playback.
	</BLOCKQUOTE>


<A name="func_trackgetmute"></A>
<B><TT>trackgetmute trackname</TT></B>
	<BLOCKQUOTE>
	Return 1 if the give track is mutted and 0 otherwise.
	</BLOCKQUOTE>

<A name="func_trackchanlist"></A>
<B><TT>trackchanlist trackname</TT></B>
	<BLOCKQUOTE>
	Return the list of channels used by events stored in track 
	<TT>trackname</TT>.
	</BLOCKQUOTE>

<A name="func_trackinfo"></A>
<B><TT>trackinfo trackname quantum evspec</TT></B>
	<BLOCKQUOTE>
	displays the number of events that match <TT>evspec</TT>
	for each measure of track <TT>trackname</TT>.
	</BLOCKQUOTE>

<H2>11.2 Channel functions</H2>

<A name="func_channew"></A>
<B><TT>channew channelname channelnum</TT></B>
	<BLOCKQUOTE>
	creates an new channel named <TT>channelname</TT>
	and bound to midi channel <TT>channelnum</TT> 
	</BLOCKQUOTE>

<A name="func_chandelete"></A>
<B><TT>chandelete channame</TT></B>
	<BLOCKQUOTE>
	delete existing channel '<TT>channame</TT>'.
	</BLOCKQUOTE>

<A name="func_chanrename"></A>
<B><TT>chanrename channame newname</TT></B>
	<BLOCKQUOTE>
	rename channel '<TT>channame</TT>' to '<TT>newname</TT>'
	</BLOCKQUOTE>

<A name="func_chanexists"></A>
<B><TT>chanexists channelname</TT></B>
	<BLOCKQUOTE>
	returns 1 if <TT>channelname</TT> is a channel, 0 otherwise
	</BLOCKQUOTE>

<A name="func_changetch"></A>
<B><TT>changetch channelname</TT></B>
	<BLOCKQUOTE>
	returns the midi channel number of channel named
	<TT>channelname</TT>
	</BLOCKQUOTE>

<A name="func_changetdev"></A>
<B><TT>changetdev channelname</TT></B>
	<BLOCKQUOTE>
	returns the device number of channel named
	<TT>channelname</TT>
	</BLOCKQUOTE>

<A name="func_chanconfev"></A>
<B><TT>chanconfev channelname event</TT></B>
	<BLOCKQUOTE>
	adds the event to the configuration of 
	channel <TT>channelname</TT>, typically used set
	the program, volume, depth etc... The channel
	of the event is not used.
	</BLOCKQUOTE>

<A name="func_chaninfo"></A>
<B><TT>chaninfo channame</TT></B>
	<BLOCKQUOTE>
	prints all events on the config
	of the channel.
	</BLOCKQUOTE>


<H2>11.3 Filter functions</H2>

<A name="func_filtnew"></A>
<B><TT>filtnew filtname</TT></B>
	<BLOCKQUOTE>
	creates an new filter named <TT>filtname</TT>
	</BLOCKQUOTE>

<A name="func_filtdelete"></A>
<B><TT>filtdelete filtname</TT></B>
	<BLOCKQUOTE>
	delete existing filter '<TT>filtname</TT>'.
	Current filter and filters used by tracks cannot be deleted.
	</BLOCKQUOTE>

<A name="func_filtrename"></A>
<B><TT>filtrename filtname newname</TT></B>
	<BLOCKQUOTE>
	rename filter '<TT>filtname</TT>' to '<TT>newname</TT>'
	</BLOCKQUOTE>

<A name="func_filtexists"></A>
<B><TT>filtexists filtname</TT></B>
	<BLOCKQUOTE>
	returns 1 if <TT>filtname</TT> is a filter, 0 otherwise
	</BLOCKQUOTE>

<A name="func_filtreset"></A>
<B><TT>filtreset filtname</TT></B>
	<BLOCKQUOTE>
	removes all rules from the filter <TT>filtname</TT>
	</BLOCKQUOTE>

<A name="func_filtinfo"></A>
<B><TT>filtinfo filtname</TT></B>
	<BLOCKQUOTE>
	lists the rules of the given filter
	</BLOCKQUOTE>

<A name="func_filtsetcurchan"></A>
<B><TT>filtsetcurchan filtname channame</TT></B>
	<BLOCKQUOTE>
	sets the default channel of filter
	<TT>filtname</TT> to <TT>channame</TT>.
	</BLOCKQUOTE>

<A name="func_filtgetcurchan"></A>
<B><TT>filtgetcurchan filtname</TT></B>
	<BLOCKQUOTE>
	returns the default channel 
	of <TT>filtname</TT>, returns <TT>nil</TT> if none
	</BLOCKQUOTE>

<A name="func_filtswapichan"></A>
<B><TT>filtswapichan filtname oldchan newchan</TT></B>
	<BLOCKQUOTE>
	changes the input channel of 
	all rules with input channel equal to <TT>oldchan</TT>
	to <TT>newchan</TT>, and the input channel of 
	all rules with input channel equal to <TT>newchan</TT>
	to <TT>oldchan</TT>,
	</BLOCKQUOTE>

<A name="func_filtswapidev"></A>
<B><TT>filtswapidev filtname olddev newdev</TT></B>
	<BLOCKQUOTE>
	changes the input device of 
	all rules with input device equal to <TT>olddev</TT>
	to <TT>newdev</TT>, and the input device of 
	all rules with input device equal to <TT>newdev</TT>
	to <TT>olddev</TT>
	</BLOCKQUOTE>

<A name="func_filtdevdrop"></A>
<B><TT>filtdevdrop filtname inputdev</TT></B>
	<BLOCKQUOTE>
	make filter drop events from device <TT>inputdev</TT>
	</BLOCKQUOTE>

<A name="func_filtnodevdrop"></A>
<B><TT>filtnodevdrop filtname inputdev</TT></B>
	<BLOCKQUOTE>
	remove <TT>devdrop</TT> rules that drop events from device <TT>inputdev</TT>
	</BLOCKQUOTE>

<A name="func_filtdevmap"></A>
<B><TT>filtdevmap filtname inputdev outputdev</TT></B>
	<BLOCKQUOTE>
	route all events from device <TT>inputdev</TT>
	to device <TT>outputdev</TT>. If multiple dev maps are 
	defined for the same input device then events are 
	duplicated
	</BLOCKQUOTE>

<A name="func_filtnodevmap"></A>
<B><TT>filtnodevmap filtname outputdev</TT></B>
	<BLOCKQUOTE>
	remove <TT>devmap</TT> rules that route events to 
	device number <TT>outputdev</TT>. 
	</BLOCKQUOTE>

<A name="func_filtchandrop"></A>
<B><TT>filtchandrop filtname inputchan</TT></B>
	<BLOCKQUOTE>
	make filter drop events from channel <TT>inputchan</TT>
	</BLOCKQUOTE>

<A name="func_filtnochandrop"></A>
<B><TT>filtnochandrop filtname inputchan</TT></B>
	<BLOCKQUOTE>
	remove <TT>chandrop</TT> rules that 
	drop events from channel <TT>inputchan</TT>
	</BLOCKQUOTE>

<A name="func_filtchanmap"></A>
<B><TT>filtchanmap filtname inputchan outputchan</TT></B>
	<BLOCKQUOTE>
	route all events from channel <TT>inputchan</TT> 
	(ie device/midi-channel pair)
	to channel <TT>outputchan</TT>. If multiple channel maps are 
	defined for the same input channle then events are 
	duplicated
	</BLOCKQUOTE>

<A name="func_filtnochanmap"></A>
<B><TT>filtnochanmap filtname outputchan</TT></B>
	<BLOCKQUOTE>
	remove channel map rules that route events to channel 
	<TT>outputchan</TT>. 
	</BLOCKQUOTE>

<A name="func_filtctldrop"></A>
<B><TT>filtctldrop filtname inchan inctl</TT></B>
	<BLOCKQUOTE>
	make the filter drop controller number <TT>inctl</TT> 
	on channel <TT>inctl</TT>.
	</BLOCKQUOTE>

<A name="func_filtnoctldrop"></A>
<B><TT>filtnoctldrop filtname inchan inctl</TT></B>
	<BLOCKQUOTE>
	remove <TT>ctldrop</TT> rules that drop controller number 
	<TT>inctl</TT> 	on channel <TT>inctl</TT>.
	</BLOCKQUOTE>

<A name="func_filtctlmap"></A>
<B><TT>filtctlmap filtname inchan outchan inctl outctl</TT></B>
	<BLOCKQUOTE>
	route controller <TT>inctl</TT> from <TT>inchan</TT>
	to controller <TT>outctl</TT> on <TT>outchan</TT>.
	If multiple ctlmaps are defined for the same input 
	channel and the same input controller then events are duplicated
	</BLOCKQUOTE>

<A name="func_filtnoctlmap"></A>
<B><TT>filtnoctlmap filtname outchan outctl</TT></B>
	<BLOCKQUOTE>
	remove <TT>ctlmap</TT> rules that route controllers to
	controller <TT>outctl</TT>, channel <TT>outchan</TT>.
	</BLOCKQUOTE>

<A name="func_filtkeydrop"></A>
<B><TT>filtkeydrop filtname inchan keystart keyend</TT></B>
	<BLOCKQUOTE>
	drop notes between <TT>keystart</TT> and <TT>keyend</TT>
	on channel <TT>inchan</TT>.
	</BLOCKQUOTE>

<A name="func_filtnokeydrop"></A>
<B><TT>filtnokeydrop filtname inchan keystart keyend</TT></B>
	<BLOCKQUOTE>
	remove <TT>keydrop</TT> rule that drop notes between 
	<TT>keystart</TT> and <TT>keyend</TT>
	on channel <TT>inchan</TT>.
	</BLOCKQUOTE>

<A name="func_filtkeymap"></A>
<B><TT>filtkeymap filtname inchan outchan keystart keyend keyplus</TT></B>
	<BLOCKQUOTE>
	route note events from channel <TT>inchan</TT> and
	in the range <TT>keystart..keyend</TT> to <TT>outchan</TT>.
	Routed notes are transposed by keyplus half-tones
	If multiple keymaps are defined for the same input 
	channel and key-range then events are duplicated
	</BLOCKQUOTE>

<A name="func_filtnokeymap"></A>
<B><TT>filtnokeymap filtname outchan keystart keyend</TT></B>
	<BLOCKQUOTE>
	remove <TT>keymap</TT> rules that route note events 
	in the range <TT>keystart..keyend</TT> to channel <TT>outchan</TT>.
	</BLOCKQUOTE>

<H2>11.4 System exclusive messages functions</H2>

<A name="func_sysexnew"></A>
<B><TT>sysexnew sysexname</TT></B>
	<BLOCKQUOTE>
	create a new bank of sysex messages named <TT>sysexname</TT>
	</BLOCKQUOTE>

<A name="func_sysexdelete"></A>
<B><TT>sysexdelete sysexname</TT></B>
	<BLOCKQUOTE>
	delete the bank of sysex messages named <TT>sysexname</TT>.
	Current 'sysex' cannot be deleted.
	</BLOCKQUOTE>

<A name="func_sysexrename"></A>
<B><TT>sysexrename sysexname newname</TT></B>
	<BLOCKQUOTE>
	rename sysex bank '<TT>sysexname</TT>' to '<TT>newname</TT>'
	</BLOCKQUOTE>

<A name="func_sysexexists"></A>
<B><TT>sysexexists sysexname</TT></B>
	<BLOCKQUOTE>
	returns 1 if <TT>sysexname</TT> is a sysex bank, 0 otherwise
	</BLOCKQUOTE>

<A name="func_sysexclear"></A>
<B><TT>sysexclear sysexname pattern</TT></B>
	<BLOCKQUOTE>
	removes all sysex messages starting with <TT>pattern</TT>
	from sysex bank <TT>sysexname</TT>. The given pattern
	is a list of bytes; an empty pattern matches any 
	sysex message.
	</BLOCKQUOTE>

<A name="func_sysexsetunit"></A>
<B><TT>sysexsetunit sysexname newunit pattern</TT></B>
	<BLOCKQUOTE>
	set device number to <TT>newunit</TT> 
	on all sysex messages starting with <TT>pattern</TT> 
	from sysex bank <TT>sysexname</TT>. The given pattern
	is a list of bytes; an empty pattern matches any 
	sysex message.
	</BLOCKQUOTE>

<A name="func_sysexadd"></A>
<B><TT>sysexadd sysexname unit data</TT></B>
	<BLOCKQUOTE>
	adds to sysex bank <TT>sysexname</TT>
	an new sysex message. <TT>data</TT> is a list containing the
	midi system exclusive message and <TT>unit</TT> is the device number to which
	the message will be sent
	</BLOCKQUOTE>

<A name="func_sysexinfo"></A>
<B><TT>sysexinfo sysexname</TT></B>
	<BLOCKQUOTE>
	print debug info about sysex bank <TT>sysexname</TT>
	</BLOCKQUOTE>

<H2>11.5 Real-time functions</H2>

<A name="func_songidle"></A>
<B><TT>songidle</TT></B>
	<BLOCKQUOTE>
	puts midi input to the midi output,
	data passes through the current filter (if any)
	or through the current track's filter (if any).
	</BLOCKQUOTE>

<A name="func_songplay"></A>
<B><TT>songplay</TT></B>
	<BLOCKQUOTE>
	plays the song from the current position.
	Input passes through the current filter (if any)
	or through the current track's filter (if any).
	</BLOCKQUOTE>

<A name="func_songrecord"></A>
<B><TT>songrecord</TT></B>
	<BLOCKQUOTE>
	plays the song and records the input.
	Input passes through the current filter (if any)
	or through the current track's filter (if any).
	</BLOCKQUOTE>

<A name="func_sendraw"></A>
<B><TT>sendraw device arrayofbytes</TT></B>
	<BLOCKQUOTE>
	sends raw midi data to device number '<TT>device</TT>',
	can be used to send system exclusive messages,
	example:
	<PRE>
	sendraw 0 { 0xF0 0x7E 0x7F 0x09 0x01 0xF7 }
	</PRE>
	</BLOCKQUOTE>

<H2>11.6 Song functions</H2>

<A name="func_songsetcurquant"></A>
<B><TT>songsetcurquant tics</TT></B>
	<BLOCKQUOTE>
	set the number of tics in the time scale 
	(for quantisation, track editing...). 
	Currently this value is not used in real-time.
	</BLOCKQUOTE>

<A name="func_songgetcurquant"></A>
<B><TT>songgetcurquant tics</TT></B>
	<BLOCKQUOTE>
	get the number of tics in the time scale.
	</BLOCKQUOTE>

<A name="func_songsetcurpos"></A>
<B><TT>songsetcurpos measure</TT></B>
	<BLOCKQUOTE>
	set the current song position pointer to
	the measure <TT>measure</TT>. record and playback
	will start a that position
	</BLOCKQUOTE>

<A name="func_songgetcurpos"></A>
<B><TT>songgetcurpos</TT></B>
	<BLOCKQUOTE>
	returns the current measure ie the
	current song position pointer
	</BLOCKQUOTE>

<A name="func_songsetcurtrack"></A>
<B><TT>songsetcurtrack trackname</TT></B>
	<BLOCKQUOTE>
	set the current track ie the track to be recorded
	</BLOCKQUOTE>

<A name="func_songgetcurtrack"></A>
<B><TT>songgetcurtrack</TT></B>
	<BLOCKQUOTE>
	returns the current track (if any) or <TT>nil</TT>
	</BLOCKQUOTE>

<A name="func_songsetcurfilt"></A>
<B><TT>songsetcurfilt filtname</TT></B>
	<BLOCKQUOTE>
	set the current filter ie the one used (with
	songplay and songidle).
	</BLOCKQUOTE>

<A name="func_songgetcurfilt"></A>
<B><TT>songgetcurfilt</TT></B>
	<BLOCKQUOTE>
	returns the current filter
	or <TT>'nil'</TT> if none
	</BLOCKQUOTE>

<A name="func_songsetcursysex"></A>
<B><TT>songsetcursysex sysexname</TT></B>
	<BLOCKQUOTE>
	set the current sysex bank, 
	ie the one that will be recorded
	</BLOCKQUOTE>

<A name="func_songgetcursysex"></A>
<B><TT>songgetcursysex</TT></B>
	<BLOCKQUOTE>
	returns the current sysex bank
	or <TT>'nil'</TT> if none
	</BLOCKQUOTE>

<A name="func_songsetcurchan"></A>
<B><TT>songsetcurchan channame</TT></B>
	<BLOCKQUOTE>
	set the current (named) channel.
	</BLOCKQUOTE>

<A name="func_songgetcurchan"></A>
<B><TT>songgetcurchan</TT></B>
	<BLOCKQUOTE>
	returns the name of the current channel 
	or <TT>'nil'</TT> if none
	</BLOCKQUOTE>

<A name="func_songsetunit"></A>
<B><TT>songsetunit tpu</TT></B>
	<BLOCKQUOTE>
	set the time resolution of the sequencer to <TT>tpu</TT>
	tics per unit (1 unit = 4 quarter notes).  the
	unit shall be changed before creating any tracks. 
	The default is 96 tics per unit, which is the
	default of the midi standard.
	</BLOCKQUOTE>

<A name="func_songgetunit"></A>
<B><TT>songgetunit</TT></B>
	<BLOCKQUOTE>
	returns the number of tics per unit note
	</BLOCKQUOTE>

<A name="func_songsettempo"></A>
<B><TT>songsettempo measure bpm</TT></B>
	<BLOCKQUOTE>
	sets the tempo to <TT>bpm</TT> beats per
	minute at measure <TT>measure</TT>
	</BLOCKQUOTE>

<A name="func_songtimeins"></A>
<B><TT>songtimeins from amount numerator denominator</TT></B>
	<BLOCKQUOTE>
	inserts <TT>amount</TT> blank measures at measure
	<TT>from</TT>. The used time signature is given
	by numerator/denominator.
	</BLOCKQUOTE>

<A name="func_songtimerm"></A>
<B><TT>songtimerm from amount</TT></B>
	<BLOCKQUOTE>
	deletes <TT>amount</TT> measures starting at
	measure <TT>from</TT>. The time signature is
	restored with the value preceding the
	<TT>from</TT> measure.
	</BLOCKQUOTE>

<A name="func_songtimeinfo"></A>
<B><TT>songtimeinfo</TT></B>
	<BLOCKQUOTE>
	print the meta-track (tempo changes, time signature
	changes
	</BLOCKQUOTE>

<A name="func_songinfo"></A>
<B><TT>songinfo</TT></B>
	<BLOCKQUOTE>
	display some info about the default values of
	the song
	</BLOCKQUOTE>

<A name="func_songsave"></A>
<B><TT>songsave filename</TT></B>
	<BLOCKQUOTE>
	saves the song in a file, <TT>filename</TT>
	is a quoted string.
	</BLOCKQUOTE>

<A name="func_songload"></A>
<B><TT>songload filename</TT></B>
	<BLOCKQUOTE>
	load the song from a file named <TT>filename</TT>.
	the current song is destroyed, even if 
	the load command failed
	</BLOCKQUOTE>

<A name="func_songreset"></A>
<B><TT>songreset</TT></B>
	<BLOCKQUOTE>
	destroy completely the song, useful to
	start a new song without restarting the
	program
	</BLOCKQUOTE>

<A name="func_songexportsmf"></A>
<B><TT>songexportsmf filename</TT></B>
	<BLOCKQUOTE>
	saves the song into a standard midi file, <TT>filename</TT>
	is a quoted string.
	</BLOCKQUOTE>

<A name="func_songimportsmf"></A>
<B><TT>songimportsmf filename</TT></B>
	<BLOCKQUOTE>
	loads the song from a standard midi file, <TT>filename</TT>
	is a quoted string. Currently only midi file "type 1" is
	supported.
	</BLOCKQUOTE>

<H2>11.7 Device functions</H2>

<A name="func_devlist"></A>
<B><TT>devlist</TT></B>
	<BLOCKQUOTE>
	returns the list of attached devices
	(list of numbers)
	</BLOCKQUOTE>

<A name="func_devattach"></A>
<B><TT>devattach devnum filename</TT></B>
	<BLOCKQUOTE>
	attach midi device <TT>filename</TT> as
	device number <TT>devnum</TT>; <TT>filename</TT>
	is a quoted string.
	</BLOCKQUOTE>

<A name="func_devdetach"></A>
<B><TT>devdetach devnum</TT></B>
	<BLOCKQUOTE>
	detach device number <TT>devnum</TT>
	</BLOCKQUOTE>

<A name="func_devmaster"></A>
<B><TT>devsetmaster devnum</TT></B>
	<BLOCKQUOTE>
	set device number <TT>devnum</TT> to be the master clock source.
	It will give tempo, start event and stop event. If <TT>devnum</TT> is
	<TT>nil</TT>, then the internal clock will be used and midish
	will act as master device.
	</BLOCKQUOTE>

<A name="func_devgetmaster"></A>
<B><TT>devgetmaster devnum</TT></B>
	<BLOCKQUOTE>
	return the current master device. If non, <TT>nil</TT> is
	returned.
	</BLOCKQUOTE>

<A name="func_devsendrt"></A>
<B><TT>devsendrt devnum bool</TT></B>
	<BLOCKQUOTE>
	If <TT>bool</TT> is true, the real-time information (midi tics, 
	midi start and midi trop events) will be transmitted to device
	number <TT>devnum</TT>. 
	Overwise no real-time midi events are transmitted.
	</BLOCKQUOTE>
	
<A name="func_devticrate"></A>
<B><TT>devticrate devnum ticrate</TT></B>
	<BLOCKQUOTE>
	set the number of tics per unit note that are transmitted
	to the midi device if "sendrt" feature is active. Defaut
	value is 96 tics. This is the standard MIDI value and
	its not recommended to change it.
	</BLOCKQUOTE>
	
<A name="func_devinfo"></A>
<B><TT>devinfo devnum</TT></B>
	<BLOCKQUOTE>
	Print some information about the midi device.
	</BLOCKQUOTE>

<H2>11.8 Misc. functions</H2>

<A name="func_metroswitch"></A>
<B><TT>metroswitch number</TT></B>
	<BLOCKQUOTE>
	if <TT>number</TT> is equal to zero then the metronome is disabled
	else it is enabled
	</BLOCKQUOTE>	

<A name="func_metroconf"></A>
<B><TT>metroconf eventhi eventlo</TT></B>
	<BLOCKQUOTE>	
	select the notes that the metronome plays. The
	pair of events must be note-ons
	</BLOCKQUOTE>
	
<A name="func_info"></A>
<B><TT>info</TT></B>
	<BLOCKQUOTE>
	display the list of built-in and user-defined
	procedures and global varables
	</BLOCKQUOTE>

<A name="func_print"></A>
<B><TT>print expression</TT></B>
	<BLOCKQUOTE>
	displays the value of the expression
	</BLOCKQUOTE>

<A name="func_exec"></A>
<B><TT>exec filename</TT></B>
	<BLOCKQUOTE>
	reads and executes the script from a file, <TT>filename</TT>
	is a quoted string.
	</BLOCKQUOTE>

<A name="func_debug"></A>
<B><TT>debug flag val</TT></B>
	<BLOCKQUOTE>
	set debug-flag <TT>flag</TT> to (integer) value <TT>val</TT>. 
	If <TT>val=0</TT> the corresponding debug-info are
	turned off. <TT>flag</TT> can be: 
	<UL>
	<LI><TT>rmidi</TT> - show raw midi trafic on stderr
	<LI><TT>filt</TT> - show events passing through the current filter 
	<LI><TT>song</TT> - show start/stop events
	</UL>
	</BLOCKQUOTE>

<A name="func_panic"></A>
<B><TT>panic</TT></B>
	<BLOCKQUOTE>
	causes the sequencer to core-dump
	</BLOCKQUOTE>
	
<HR>
<SMALL><EM>
Copyright (c) 2003-2005 Alexandre Ratchov<BR>
Last updated aug 23, 2005 
</EM></SMALL>

</BODY>
</HTML>
